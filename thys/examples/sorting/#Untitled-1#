simplification rules:
    str_sort.equidist_impl \<equiv>
    \<lambda>ai bi. doM {
         x \<leftarrow> narray_new TYPE(64 word) bi;
         xa \<leftarrow> ll_udiv ai bi;
         xb \<leftarrow> ll_urem ai bi;
         (a1, a1a, a1b, y) \<leftarrow> llc_while (\<lambda>(a1, a1a, a1b, a2b). ll_icmp_slt a1 bi) (\<lambda>(a1, a1a, a1b, a2b). doM {
                                                                                        x \<leftarrow> array_upd a2b a1 a1a;
 xb \<leftarrow> ll_add a1 1;
 xa \<leftarrow> ll_add a1a xa;
 xc \<leftarrow> ll_icmp_slt 0 a1b;
 (a1c, a2c) \<leftarrow> llc_if xc (doM {
                            x \<leftarrow> ll_add xa 1;
                            xa \<leftarrow> ll_sub a1b 1;
                            return (x, xa)
                          })
                (return (xa, a1b));
 return (xb, a1c, a2c, x)
                                                                                      })
                               (0, 0, xb, x);
         return y
       }
    str_sort.bad_partition_impl \<equiv> \<lambda>ai bi. doM {
                                        x \<leftarrow> ll_udiv bi 8;
                                        x \<leftarrow> ll_icmp_slt ai x;
                                        xa \<leftarrow> ll_sub bi ai;
                                        xb \<leftarrow> ll_udiv bi 8;
                                        ll_icmp_slt xa xb \<bind> ll_or x
                                      }
    str_sort.shuffle_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                  x \<leftarrow> snat_sub_impl bia bib;
                                  xa \<leftarrow> snat_sub_impl bi bib;
                                  xb \<leftarrow> snat_add_bnd_impl bia bi 1;
                                  xb \<leftarrow> snat_sub_impl bia xb;
                                  x \<leftarrow> snat_div_impl x 8;
                                  xc \<leftarrow> ll_icmp_slt xa x;
                                  x \<leftarrow> ll_icmp_slt xb x;
                                  x \<leftarrow> ll_or xc x;
                                  llc_if x (doM {
                                              x \<leftarrow> ll_icmp_sle 0x10 xa;
                                              x \<leftarrow> llc_if x (doM {
                                                               x \<leftarrow> snat_div_impl xa 4;
                                                               xb \<leftarrow> snat_add_bnd_impl bia bib x;
                                                               xc \<leftarrow> snat_sub_impl bi 1;
                                                               x \<leftarrow> snat_sub_impl bi x;
                                                               xd \<leftarrow> swap_eos_impl ai bib xb;
                                                               xc \<leftarrow> swap_eos_impl xd xc x;
                                                               xa \<leftarrow> ll_icmp_slt 0x80 xa;
                                                               llc_if xa (doM {
                                                                            xa \<leftarrow> snat_add_bnd_impl bia bib 1;
                                                                            xd \<leftarrow> snat_add_bnd_impl bia bib 2;
                                                                            xe \<leftarrow> snat_sub_impl bi 2;
                                                                            xf \<leftarrow> snat_sub_impl bi 3;
                                                                            xg \<leftarrow> snat_add_bnd_impl bia xb 1;
                                                                            xb \<leftarrow> snat_add_bnd_impl bia xb 2;
                                                                            xh \<leftarrow> snat_sub_impl x 1;
                                                                            x \<leftarrow> snat_sub_impl x 2;
                                                                            xa \<leftarrow> swap_eos_impl xc xa xg;
                                                                            xa \<leftarrow> swap_eos_impl xa xd xb;
                                                                            xa \<leftarrow> swap_eos_impl xa xe xh;
                                                                            swap_eos_impl xa xf x
                                                                          })
                                                                (return xc)
                                                             })
                                                    (return ai);
                                              xa \<leftarrow> ll_icmp_sle 0x10 xb;
                                              x \<leftarrow> llc_if xa (doM {
                                                                xa \<leftarrow> snat_add_bnd_impl bia bi 1;
                                                                xc \<leftarrow> snat_sub_impl bia 1;
                                                                xd \<leftarrow> snat_div_impl xb 4;
                                                                xe \<leftarrow> snat_add_bnd_impl bia xa xd;
                                                                xd \<leftarrow> snat_sub_impl bia xd;
                                                                x \<leftarrow> swap_eos_impl x xa xe;
                                                                x \<leftarrow> swap_eos_impl x xc xd;
                                                                xa \<leftarrow> ll_icmp_slt 0x80 xb;
                                                                llc_if xa (doM {
                                                                             xa \<leftarrow> snat_add_bnd_impl bia bi 2;
                                                                             xb \<leftarrow> snat_add_bnd_impl bia bi 3;
                                                                             xc \<leftarrow> snat_sub_impl bia 2;
                                                                             xf \<leftarrow> snat_sub_impl bia 3;
                                                                             xg \<leftarrow> snat_sub_impl xd 1;
                                                                             xd \<leftarrow> snat_sub_impl xd 2;
                                                                             xh \<leftarrow> snat_add_bnd_impl bia xe 1;
                                                                             xe \<leftarrow> snat_add_bnd_impl bia xe 2;
                                                                             x \<leftarrow> swap_eos_impl x xa xh;
                                                                             x \<leftarrow> swap_eos_impl x xb xe;
                                                                             x \<leftarrow> swap_eos_impl x xc xg;
                                                                             swap_eos_impl x xf xd
                                                                           })
                                                                 (return x)
                                                              })
                                                    (return x);
                                              return (1, x)
                                            })
                                   (return (0, ai))
                                }
    unat_sort.shuffle_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                   x \<leftarrow> snat_sub_impl bia bib;
                                   xa \<leftarrow> snat_sub_impl bi bib;
                                   xb \<leftarrow> snat_add_bnd_impl bia bi 1;
                                   xb \<leftarrow> snat_sub_impl bia xb;
                                   x \<leftarrow> snat_div_impl x 8;
                                   xc \<leftarrow> ll_icmp_slt xa x;
                                   x \<leftarrow> ll_icmp_slt xb x;
                                   x \<leftarrow> ll_or xc x;
                                   llc_if x (doM {
                                               x \<leftarrow> ll_icmp_sle 0x10 xa;
                                               x \<leftarrow> llc_if x (doM {
                                                                x \<leftarrow> snat_div_impl xa 4;
                                                                xb \<leftarrow> snat_add_bnd_impl bia bib x;
                                                                xc \<leftarrow> snat_sub_impl bi 1;
                                                                x \<leftarrow> snat_sub_impl bi x;
                                                                xd \<leftarrow> swap_eos_impl ai bib xb;
                                                                xc \<leftarrow> swap_eos_impl xd xc x;
                                                                xa \<leftarrow> ll_icmp_slt 0x80 xa;
                                                                llc_if xa (doM {
                                                                             xa \<leftarrow> snat_add_bnd_impl bia bib 1;
                                                                             xd \<leftarrow> snat_add_bnd_impl bia bib 2;
                                                                             xe \<leftarrow> snat_sub_impl bi 2;
                                                                             xf \<leftarrow> snat_sub_impl bi 3;
                                                                             xg \<leftarrow> snat_add_bnd_impl bia xb 1;
                                                                             xb \<leftarrow> snat_add_bnd_impl bia xb 2;
                                                                             xh \<leftarrow> snat_sub_impl x 1;
                                                                             x \<leftarrow> snat_sub_impl x 2;
                                                                             xa \<leftarrow> swap_eos_impl xc xa xg;
                                                                             xa \<leftarrow> swap_eos_impl xa xd xb;
                                                                             xa \<leftarrow> swap_eos_impl xa xe xh;
                                                                             swap_eos_impl xa xf x
                                                                           })
                                                                 (return xc)
                                                              })
                                                     (return ai);
                                               xa \<leftarrow> ll_icmp_sle 0x10 xb;
                                               x \<leftarrow> llc_if xa (doM {
                                                                 xa \<leftarrow> snat_add_bnd_impl bia bi 1;
                                                                 xc \<leftarrow> snat_sub_impl bia 1;
                                                                 xd \<leftarrow> snat_div_impl xb 4;
                                                                 xe \<leftarrow> snat_add_bnd_impl bia xa xd;
                                                                 xd \<leftarrow> snat_sub_impl bia xd;
                                                                 x \<leftarrow> swap_eos_impl x xa xe;
                                                                 x \<leftarrow> swap_eos_impl x xc xd;
                                                                 xa \<leftarrow> ll_icmp_slt 0x80 xb;
                                                                 llc_if xa (doM {
                                                                              xa \<leftarrow> snat_add_bnd_impl bia bi 2;
                                                                              xb \<leftarrow> snat_add_bnd_impl bia bi 3;
                                                                              xc \<leftarrow> snat_sub_impl bia 2;
                                                                              xf \<leftarrow> snat_sub_impl bia 3;
                                                                              xg \<leftarrow> snat_sub_impl xd 1;
                                                                              xd \<leftarrow> snat_sub_impl xd 2;
                                                                              xh \<leftarrow> snat_add_bnd_impl bia xe 1;
                                                                              xe \<leftarrow> snat_add_bnd_impl bia xe 2;
                                                                              x \<leftarrow> swap_eos_impl x xa xh;
                                                                              x \<leftarrow> swap_eos_impl x xb xe;
                                                                              x \<leftarrow> swap_eos_impl x xc xg;
                                                                              swap_eos_impl x xf xd
                                                                            })
                                                                  (return x)
                                                               })
                                                     (return x);
                                               return (1, x)
                                             })
                                    (return (0, ai))
                                 }
    snat.am2_lookup \<equiv> \<lambda>ai bi. array_nth bi ai
    hm_has_next_child_impl \<equiv> \<lambda>ai bi. hm_length_impl ai \<bind> ll_icmp_slt bi
    ial_length_impl \<equiv> \<lambda>xi. case xi of (a1, a2) \<Rightarrow> marl_length_impl a1
    ial_index_impl \<equiv> \<lambda>ai bi. case ai of (a1, a2) \<Rightarrow> array_nth a2 bi
    hm_parent_valid_impl \<equiv> \<lambda>ai. ll_icmp_slt 1
    hm_contains_key_impl \<equiv> \<lambda>ai bi. case bi of (a1, a2) \<Rightarrow> ial_contains_impl ai a1
    snat_sub_ovf_impl \<equiv> \<lambda>ai bi. doM {
                              x \<leftarrow> ll_icmp_sle ai bi;
                              llc_if x (return 0) (ll_sub ai bi)
                            }
    marl_is_empty_impl \<equiv> \<lambda>xi. case xi of (a1, a2) \<Rightarrow> ll_icmp_eq a1 0
    ial_get_impl \<equiv> \<lambda>ai bi. case ai of (a1, a2) \<Rightarrow> marl_get_impl a1 bi
    hm_the_lookup_impl \<equiv> \<lambda>ai bi. case bi of (a1, x) \<Rightarrow> amt_lookup_impl ai x
    hm_next_child_impl \<equiv> \<lambda>xi. ll_add xi 1
    hm_left_child_impl \<equiv> ll_mul 2
    amt_update_impl \<equiv> \<lambda>ai bia bi. array_upd bi ai bia
    amt_lookup_impl \<equiv> \<lambda>ai bi. array_nth bi ai
    arl_initial_size \<equiv> return (signed_nat 8)
    marl_length_impl \<equiv> \<lambda>xi. return (case xi of (a1, a2) \<Rightarrow> a1)
    hm_has_child_impl \<equiv> \<lambda>ai bi. doM {
                              x \<leftarrow> hm_length_impl ai;
                              ll_udiv x 2 \<bind> ll_icmp_sle bi
                            }
    snat_am_contains_key \<equiv> \<lambda>ai bi. doM {
                                 x \<leftarrow> array_nth bi ai;
                                 xa \<leftarrow> ll_icmp_eq (- 1) x;
                                 r \<leftarrow> ll_add xa 1;
                                 snat.free_option (\<lambda>_. return ()) x;
                                 return r
                               }
    marl_empty_impl \<equiv> \<lambda>xi. doM {
                            x \<leftarrow> narray_new_init xi init;
                            return (0, x)
                          }
    hm_is_empty_impl \<equiv> \<lambda>xi. doM {
                             x \<leftarrow> hm_length_impl xi;
                             ll_icmp_eq x 0
                           }
    amt_init_impl \<equiv> \<lambda>xi. narray_new_init xi init
    hm_prio_of_impl \<equiv> \<lambda>ai bi. hm_val_of_impl ai bi \<bind> return
    hm_butlast_impl \<equiv> \<lambda>xi. case xi of (a1, a2) \<Rightarrow> doM {
                                           x \<leftarrow> ial_length_impl a1;
                                           x \<leftarrow> ll_sub x 1;
                                           ial_get_impl a1 x;
                                           x \<leftarrow> ial_butlast_impl a1;
                                           return (x, a2)
                                         }
    la_replicate_init_impl \<equiv> \<lambda>xi. doM {
                                   x \<leftarrow> narray_new TYPE(?'b) xi;
                                   return (xi, x)
                                 }
    mop_rchild_impl \<equiv> \<lambda>ai bi. doM {
                            x \<leftarrow> ll_mul 2 bi;
                            ll_add x 2
                          }
    mop_lchild_impl \<equiv> \<lambda>ai bi. doM {
                            x \<leftarrow> ll_mul 2 bi;
                            ll_add x 1
                          }
    has_rchild_impl \<equiv> \<lambda>ai bia bi. doM {
                            x \<leftarrow> ll_sub bia ai;
                            x \<leftarrow> ll_sub x 1;
                            ll_udiv x 2 \<bind> ll_icmp_slt bi
                          }
    has_lchild_impl \<equiv> \<lambda>ai bia bi. doM {
                            x \<leftarrow> ll_sub bia ai;
                            ll_udiv x 2 \<bind> ll_icmp_slt bi
                          }
    marl_set_impl \<equiv> \<lambda>ai bia bi. case ai of (a1, a2) \<Rightarrow> doM {
                                                x \<leftarrow> array_upd a2 bia bi;
                                                return (a1, x)
                                              }
    marl_get_impl \<equiv> \<lambda>ai bi. case ai of (a1, a2) \<Rightarrow> array_nth a2 bi
    hm_val_of_impl \<equiv> \<lambda>ai bi. doM {
                           x \<leftarrow> hm_key_of_impl ai bi;
                           hm_the_lookup_impl x ai
                         }
    hm_parent_impl \<equiv> \<lambda>xi. ll_udiv xi 2
    hm_length_impl \<equiv> \<lambda>xi. case xi of (a1, a2) \<Rightarrow> ial_length_impl a1
    hm_key_of_impl \<equiv> \<lambda>ai bi. case ai of (a1, a2) \<Rightarrow> ll_sub bi 1 \<bind> ial_get_impl a1
    hm_append_impl \<equiv> \<lambda>ai bia bi. case ai of (a1, a2) \<Rightarrow> doM {
                                                 x \<leftarrow> ial_append_impl a1 bia;
                                                 xa \<leftarrow> amt_update_impl bia bi a2;
                                                 return (x, xa)
                                               }
    array_of_arl \<equiv> \<lambda>(l, c, a). a
    snat_add_bnd_impl \<equiv> \<lambda>ai. ll_add
    mop_seth_impl \<equiv> \<lambda>ai bic bib bia bi. doM {
                          x \<leftarrow> ll_add ai bia;
                          array_upd bib x bi
                        }
    mop_geth_impl \<equiv> \<lambda>ai bib bia bi. ll_add ai bi \<bind> eo_extract_impl bia
    ll_implies \<equiv> \<lambda>ai bi. doM {
                       x \<leftarrow> ll_add ai 1;
                       ll_or x bi
                     }
    arl_new_raw \<equiv> doM {
      c \<leftarrow> arl_initial_size;
      a \<leftarrow> narray_new TYPE(?'a) c;
      return (signed_nat 0, c, a)
    }
    h_peek_min_impl \<equiv> \<lambda>xi. ll_sub 1 1 \<bind> arl_nth xi
    h_is_empty_impl \<equiv> \<lambda>xi. doM {
                            x \<leftarrow> arl_len xi;
                            ll_icmp_eq x 0
                          }
    h_prio_of_impl \<equiv> \<lambda>ai bi. (ll_sub bi 1 \<bind> arl_nth ai) \<bind> return
    h_pop_min_impl \<equiv> \<lambda>xi. doM {
                           x \<leftarrow> ll_sub 1 1 \<bind> arl_nth xi;
                           xa \<leftarrow> arl_len xi;
                           xb \<leftarrow> doM {
                               x \<leftarrow> ll_sub 1 1;
                               x \<leftarrow> arl_nth xi x;
                               xb \<leftarrow> ll_sub xa 1;
                               xb \<leftarrow> arl_nth xi xb;
                               xc \<leftarrow> ll_sub 1 1;
                               xb \<leftarrow> arl_upd xi xc xb;
                               xa \<leftarrow> ll_sub xa 1;
                               arl_upd xb xa x
                             };
                           xb \<leftarrow> arl_butlast xb;
                           xa \<leftarrow> ll_icmp_ne xa 1;
                           llc_if xa (doM {
                                        xa \<leftarrow> h_sink_impl xb 1;
                                        return (x, xa)
                                      })
                            (return (x, xb))
                         }
    snat_am_update \<equiv> \<lambda>ai bia bi. doM {
                           r \<leftarrow> array_upd bi ai bia;
                           snat.free_option (\<lambda>_. return ()) bia;
                           return r
                         }
    snat_am_lookup \<equiv> \<lambda>ai bi. array_nth bi ai
    snat_am_delete \<equiv> \<lambda>ai bi. doM {
                           r \<leftarrow> array_upd bi ai (- 1);
                           snat.free_option (\<lambda>_. return ()) (- 1);
                           return r
                         }
    compare_impl \<equiv>
    \<lambda>ai bia bi. doM {
         (a1, y) \<leftarrow> llc_while (\<lambda>(a1, a2). doM {
                                    x \<leftarrow> ll_icmp_slt a1 bi;
                                    ll_icmp_eq a2 0 \<bind> ll_and x
                                  })
                     (\<lambda>(a1, a2). doM {
                           x \<leftarrow> arl_nth ai a1;
                           xa \<leftarrow> arl_nth bia a1;
                           xb \<leftarrow> ll_icmp_eq x xa;
                           llc_if xb (doM {
                                        x \<leftarrow> ll_add a1 1;
                                        return (x, 0)
                                      })
                            (doM {
                               x \<leftarrow> ll_icmp_ult x xa;
                               llc_if x (doM {
                                           x \<leftarrow> ll_add a1 1;
                                           return (x, - 1)
                                         })
                                (doM {
                                   x \<leftarrow> ll_add a1 1;
                                   return (x, 1)
                                 })
                             })
                         })
                     (0, 0);
         return y
       }
    h_val_of_impl \<equiv> \<lambda>ai bi. ll_sub bi 1 \<bind> arl_nth ai
    h_update_impl \<equiv> \<lambda>ai bia bi. doM {
                          x \<leftarrow> ll_sub bia 1;
                          arl_upd ai x bi
                        }
    h_insert_impl \<equiv> \<lambda>ai bi. doM {
                          x \<leftarrow> arl_push_back bi ai;
                          arl_len x \<bind> h_swim_impl x
                        }
    h_append_impl \<equiv> arl_push_back
    snat_am_empty \<equiv> \<lambda>xi. doM {
                          r \<leftarrow> narray_new_init xi (- 1);
                          snat.free_option (\<lambda>_. return ()) (- 1);
                          return r
                        }
    la_replicate_impl \<equiv> \<lambda>ai bi. doM {
                              x \<leftarrow> narray_new_init ai bi;
                              return (ai, x)
                            }
    la_grow_init_impl \<equiv> \<lambda>ai bia bi. case bi of (a1, a2) \<Rightarrow> doM {
                                                    x \<leftarrow> array_grow ai bia a2;
                                                    return (ai, x)
                                                  }
    word_log2_impl \<equiv> \<lambda>xi. doM {
                           x \<leftarrow> ll_sub (word_of_nat LENGTH(?'a)) 1;
                           word_clz_impl xi \<bind> ll_sub x
                         }
    h_valid_impl \<equiv> \<lambda>ai bi. doM {
                         x \<leftarrow> ll_icmp_slt 0 bi;
                         xa \<leftarrow> arl_len ai;
                         ll_icmp_sle bi xa \<bind> ll_and x
                       }
    h_empty_impl \<equiv> arl_new_raw
    la_is_empty_impl \<equiv> \<lambda>xi. case xi of (a1, a2) \<Rightarrow> ll_icmp_eq a1 0
    snat_sub_impl \<equiv> ll_sub
    snat_div_impl \<equiv> ll_udiv
    h_exch_impl \<equiv> \<lambda>ai bia bi. doM {
                        x \<leftarrow> ll_sub bia 1;
                        x \<leftarrow> arl_nth ai x;
                        xa \<leftarrow> ll_sub bi 1;
                        xa \<leftarrow> arl_nth ai xa;
                        xb \<leftarrow> ll_sub bia 1;
                        xa \<leftarrow> arl_upd ai xb xa;
                        xb \<leftarrow> ll_sub bi 1;
                        arl_upd xa xb x
                      }
    ll_max_uint \<equiv> ll_sub 0 1
    ll_max_snat \<equiv> ll_max_sint
    ll_max_sint \<equiv> doM {
      r \<leftarrow> ll_max_uint;
      ll_lshr r 1
    }
    la_length_impl \<equiv> \<lambda>xi. return (case xi of (a1, a2) \<Rightarrow> a1)
    la_free_impl \<equiv> \<lambda>xi. case xi of (a1, x) \<Rightarrow> narray_free x
    la_set_impl \<equiv> \<lambda>ai bia bi. case ai of (a1, a2) \<Rightarrow> doM {
                                              x \<leftarrow> array_upd a2 bia bi;
                                              return (a1, x)
                                            }
    la_get_impl \<equiv> \<lambda>ai bi. case ai of (a1, a2) \<Rightarrow> array_nth a2 bi
    array_swap \<equiv> \<lambda>ai bia bi. doM {
                       x \<leftarrow> array_nth ai bia;
                       xa \<leftarrow> array_nth ai bi;
                       xa \<leftarrow> array_upd ai bia xa;
                       array_upd xa bi x
                     }
    1 \<equiv> Numeral1
    id \<equiv> \<lambda>x. x
    prod_extract_snd ?p \<equiv> ll_extract_value ?p 1
    prod_extract_fst ?p \<equiv> ll_extract_value ?p 0
    arl_new_sz_raw ?n \<equiv> doM {
      a \<leftarrow> narray_new TYPE(?'a) ?n;
      return (?n, ?n, a)
    }
    arl_pop_back ?al \<equiv> doM {
      let (l, c, a) = ?al;
      l \<leftarrow> ll_sub l (signed_nat 1);
      r \<leftarrow> array_nth a l;
      return (r, l, c, a)
    }
    aal_new_raw ?n \<equiv> doM {
      a \<leftarrow> nao_new TYPE(?'l word \<times> ?'l word \<times> ?'a ptr) ?n;
      return (?n, a)
    }
    from_bool (to_bool ?y) \<equiv> ?y
    from_bool (?a \<noteq> ?b) \<equiv> ll_cmp'_ne ?a ?b
    from_bool (?a \<le> ?b) \<equiv> ll_cmp'_ule ?a ?b
    from_bool (?a < ?b) \<equiv> ll_cmp'_ult ?a ?b
    from_bool (?a <s ?b) \<equiv> ll_cmp'_slt ?a ?b
    from_bool (?a \<le>s ?b) \<equiv> ll_cmp'_sle ?a ?b
    from_bool (?a = ?b) \<equiv> ll_cmp'_eq ?a ?b
    arl_butlast ?al \<equiv> doM {
      let (l, c, a) = ?al;
      l \<leftarrow> ll_sub l (signed_nat 1);
      return (l, c, a)
    }
    len_of ?uu1 \<equiv> 0
    len_of ?uu1 \<equiv> 1
    len_of ?uu1 \<equiv> 2 * LENGTH(?'a1)
    len_of ?uu1 \<equiv> 2 * LENGTH(?'a1) + 1
    neg_numeral_class.dbl_inc 0 \<equiv> 1
    neg_numeral_class.dbl_inc 1 \<equiv> 3
    neg_numeral_class.dbl_inc (- 1) \<equiv> - 1
    neg_numeral_class.dbl_inc (- numeral ?k1) \<equiv> - neg_numeral_class.dbl_dec (numeral ?k1)
    neg_numeral_class.dbl_inc (numeral ?k1) \<equiv> numeral (num.Bit1 ?k1)
    neg_numeral_class.dbl_dec 0 \<equiv> - 1
    neg_numeral_class.dbl_dec 1 \<equiv> 1
    neg_numeral_class.dbl_dec (- 1) \<equiv> - 3
    neg_numeral_class.dbl_dec (- numeral ?k1) \<equiv> - neg_numeral_class.dbl_inc (numeral ?k1)
    neg_numeral_class.dbl_dec (numeral ?k1) \<equiv> numeral (Num.BitM ?k1)
    arl_clear ?al \<equiv> let (l, c, a) = ?al in return (signed_nat 0, c, a)
    unat_snat_conv ?x \<equiv> return ?x
    snat_unat_conv ?x \<equiv> return ?x
    nao_open ?a \<equiv> return ()
    \<lambda>(a, b). ?f1 a b \<equiv> \<lambda>x. doM {
                             a \<leftarrow> prod_extract_fst x;
                             prod_extract_snd x \<bind> ?f1 a
                           }
    of_nat (numeral ?n1) \<equiv> numeral ?n1
    arl_last ?al \<equiv> doM {
      let (l, c, a) = ?al;
      l \<leftarrow> ll_sub l (signed_nat 1);
      array_nth a l \<bind> return
    }
    arl_free ?al \<equiv> let (uu_, uu_, a) = ?al in narray_free a
    aal_len ?na \<equiv> let (n, a) = ?na in return n
    ll_not ?a \<equiv> doM {
      a \<leftarrow> ll_sub 0 ?a;
      ll_sub a 1
    }
    arl_len ?al \<equiv> let (l, c, a) = ?al in return l
    unsigned_nat ?c \<equiv> ?c
    - 0 \<equiv> 0
    neg_numeral_class.dbl 0 \<equiv> 0
    neg_numeral_class.dbl 1 \<equiv> 2
    neg_numeral_class.dbl (- 1) \<equiv> - 2
    neg_numeral_class.dbl (- numeral ?k1) \<equiv> - neg_numeral_class.dbl (numeral ?k1)
    neg_numeral_class.dbl (numeral ?k1) \<equiv> numeral (num.Bit0 ?k1)
    array_free ?a \<equiv> ll_free ?a
    signed_nat ?c \<equiv> ?c
    ll_cmp ?b \<equiv> return (from_bool ?b)
    LLVM_DS_Arith.unsigned ?c \<equiv> ?c
    LLVM_DS_Arith.signed ?c \<equiv> ?c
    \<bar>0\<bar> \<equiv> 0
    \<bar>1\<bar> \<equiv> 1
    \<bar>- numeral ?n1\<bar> \<equiv> numeral ?n1
    \<bar>numeral ?n1\<bar> \<equiv> numeral ?n1
    pred_numeral num.One \<equiv> 0
    pred_numeral (num.Bit1 ?k1) \<equiv> numeral (num.Bit0 ?k1)
    pred_numeral (num.Bit0 ?k1) \<equiv> numeral (Num.BitM ?k1)
    M_CONST str_sort.pdq_is_unguarded_insert_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> ll_sub bi 1;
         x \<leftarrow> str_sort.cmpo_idxs_impl ai bi x;
         llc_if x (doM {
                     (a1, a2) \<leftarrow> eo_extract_impl ai bi;
                     x \<leftarrow> ll_sub bi 1;
                     (a1a, a2a) \<leftarrow> eo_extract_impl a2 x;
                     x \<leftarrow> array_upd a2a bi a1a;
                     xa \<leftarrow> ll_sub bi 1;
                     (a1b, a2b) \<leftarrow> llc_while (\<lambda>(a1b, a2b). ll_sub a2b 1 \<bind> str_sort.cmpo_v_idx_impl a1b a1) (\<lambda>(a1b, a2b). doM {
                            x \<leftarrow> ll_sub a2b 1;
                            (a1c, a2c) \<leftarrow> eo_extract_impl a1b x;
                            x \<leftarrow> array_upd a2c a2b a1c;
                            xa \<leftarrow> ll_sub a2b 1;
                            return (x, xa)
                          })
                                    (x, xa);
                     array_upd a1b a2b a1
                   })
          (return ai)
       }
    M_CONST unat_sort.pdq_is_unguarded_insert_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> ll_sub bi 1;
         x \<leftarrow> unat_sort.cmpo_idxs_impl ai bi x;
         llc_if x (doM {
                     (a1, a2) \<leftarrow> eo_extract_impl ai bi;
                     x \<leftarrow> ll_sub bi 1;
                     (a1a, a2a) \<leftarrow> eo_extract_impl a2 x;
                     x \<leftarrow> array_upd a2a bi a1a;
                     xa \<leftarrow> ll_sub bi 1;
                     (a1b, a2b) \<leftarrow> llc_while (\<lambda>(a1b, a2b). ll_sub a2b 1 \<bind> unat_sort.cmpo_v_idx_impl a1b a1) (\<lambda>(a1b, a2b). doM {
                             x \<leftarrow> ll_sub a2b 1;
                             (a1c, a2c) \<leftarrow> eo_extract_impl a1b x;
                             x \<leftarrow> array_upd a2c a2b a1c;
                             xa \<leftarrow> ll_sub a2b 1;
                             return (x, xa)
                           })
                                    (x, xa);
                     array_upd a1b a2b a1
                   })
          (return ai)
       }
    M_CONST str_sort.move_median_to_first_impl \<equiv>
    \<lambda>ai bic bib bia bi. doM {
         x \<leftarrow> str_sort.cmp_idxs_impl bi bic bib;
         llc_if x (doM {
                     x \<leftarrow> str_sort.cmp_idxs_impl bi bib bia;
                     llc_if x (swap_eos_impl bi ai bib) (doM {
                                                           x \<leftarrow> str_sort.cmp_idxs_impl bi bic bia;
                                                           llc_if x (swap_eos_impl bi ai bia) (swap_eos_impl bi ai bic)
                                                         })
                   })
          (doM {
             x \<leftarrow> str_sort.cmp_idxs_impl bi bic bia;
             llc_if x (swap_eos_impl bi ai bic) (doM {
                                                   x \<leftarrow> str_sort.cmp_idxs_impl bi bib bia;
                                                   llc_if x (swap_eos_impl bi ai bia) (swap_eos_impl bi ai bib)
                                                 })
           })
       }
    M_CONST unat_sort.move_median_to_first_impl \<equiv>
    \<lambda>ai bic bib bia bi. doM {
         x \<leftarrow> unat_sort.cmp_idxs_impl bi bic bib;
         llc_if x (doM {
                     x \<leftarrow> unat_sort.cmp_idxs_impl bi bib bia;
                     llc_if x (swap_eos_impl bi ai bib) (doM {
                                                           x \<leftarrow> unat_sort.cmp_idxs_impl bi bic bia;
                                                           llc_if x (swap_eos_impl bi ai bia) (swap_eos_impl bi ai bic)
                                                         })
                   })
          (doM {
             x \<leftarrow> unat_sort.cmp_idxs_impl bi bic bia;
             llc_if x (swap_eos_impl bi ai bic) (doM {
                                                   x \<leftarrow> unat_sort.cmp_idxs_impl bi bib bia;
                                                   llc_if x (swap_eos_impl bi ai bia) (swap_eos_impl bi ai bib)
                                                 })
           })
       }
    M_CONST str_sort.pdq_is_guarded_insert_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> ll_icmp_slt bia bi;
         x \<leftarrow> llc_if x (ll_sub bi 1 \<bind> str_sort.cmpo_idxs_impl ai bi) (return 0);
         llc_if x
          (doM {
             (a1, a2) \<leftarrow> eo_extract_impl ai bi;
             x \<leftarrow> ll_sub bi 1;
             (a1a, a2a) \<leftarrow> eo_extract_impl a2 x;
             x \<leftarrow> array_upd a2a bi a1a;
             xa \<leftarrow> ll_sub bi 1;
             (a1b, a2b) \<leftarrow> llc_while (\<lambda>(a1b, a2b). doM {
                                           x \<leftarrow> ll_icmp_slt bia a2b;
                                           llc_if x (ll_sub a2b 1 \<bind> str_sort.cmpo_v_idx_impl a1b a1) (return 0)
                                         })
                            (\<lambda>(a1b, a2b). doM {
                                  x \<leftarrow> ll_sub a2b 1;
                                  (a1c, a2c) \<leftarrow> eo_extract_impl a1b x;
                                  x \<leftarrow> array_upd a2c a2b a1c;
                                  xa \<leftarrow> ll_sub a2b 1;
                                  return (x, xa)
                                })
                            (x, xa);
             array_upd a1b a2b a1
           })
          (return ai)
       }
    M_CONST unat_sort.pdq_is_guarded_insert_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> ll_icmp_slt bia bi;
         x \<leftarrow> llc_if x (ll_sub bi 1 \<bind> unat_sort.cmpo_idxs_impl ai bi) (return 0);
         llc_if x
          (doM {
             (a1, a2) \<leftarrow> eo_extract_impl ai bi;
             x \<leftarrow> ll_sub bi 1;
             (a1a, a2a) \<leftarrow> eo_extract_impl a2 x;
             x \<leftarrow> array_upd a2a bi a1a;
             xa \<leftarrow> ll_sub bi 1;
             (a1b, a2b) \<leftarrow> llc_while (\<lambda>(a1b, a2b). doM {
                                           x \<leftarrow> ll_icmp_slt bia a2b;
                                           llc_if x (ll_sub a2b 1 \<bind> unat_sort.cmpo_v_idx_impl a1b a1) (return 0)
                                         })
                            (\<lambda>(a1b, a2b). doM {
                                  x \<leftarrow> ll_sub a2b 1;
                                  (a1c, a2c) \<leftarrow> eo_extract_impl a1b x;
                                  x \<leftarrow> array_upd a2c a2b a1c;
                                  xa \<leftarrow> ll_sub a2b 1;
                                  return (x, xa)
                                })
                            (x, xa);
             array_upd a1b a2b a1
           })
          (return ai)
       }
    M_CONST str_sort.partition_pivot_impl \<equiv> \<lambda>ai bia bi. doM {
                                                  x \<leftarrow> ll_sub bi bia;
                                                  x \<leftarrow> ll_udiv x 2;
                                                  x \<leftarrow> ll_add bia x;
                                                  xa \<leftarrow> ll_add bia 1;
                                                  xb \<leftarrow> ll_sub bi 1;
                                                  x \<leftarrow> str_sort.move_median_to_first_impl bia xa x xb ai;
                                                  xa \<leftarrow> ll_add bia 1;
                                                  (a, b) \<leftarrow> str_sort.qs_partition_impl xa bi bia x;
                                                  return (a, b)
                                                }
    M_CONST unat_sort.partition_pivot_impl \<equiv> \<lambda>ai bia bi. doM {
                                                   x \<leftarrow> ll_sub bi bia;
                                                   x \<leftarrow> ll_udiv x 2;
                                                   x \<leftarrow> ll_add bia x;
                                                   xa \<leftarrow> ll_add bia 1;
                                                   xb \<leftarrow> ll_sub bi 1;
                                                   x \<leftarrow> unat_sort.move_median_to_first_impl bia xa x xb ai;
                                                   xa \<leftarrow> ll_add bia 1;
                                                   (a, b) \<leftarrow> unat_sort.qs_partition_impl xa bi bia x;
                                                   return (a, b)
                                                 }
    M_CONST str_sort.maybe_is_insert_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> ll_icmp_slt bia bi;
         x \<leftarrow> llc_if x (ll_sub bi 1 \<bind> str_sort.cmpo_idxs_impl ai bi) (return 0);
         llc_if x
          (doM {
             (a1, a2) \<leftarrow> eo_extract_impl ai bi;
             x \<leftarrow> ll_sub bi 1;
             (a1a, a2a) \<leftarrow> eo_extract_impl a2 x;
             x \<leftarrow> array_upd a2a bi a1a;
             xa \<leftarrow> ll_sub bi 1;
             (a1b, a2b) \<leftarrow> llc_while (\<lambda>(a1b, a2b). doM {
                                           x \<leftarrow> ll_icmp_slt bia a2b;
                                           llc_if x (ll_sub a2b 1 \<bind> str_sort.cmpo_v_idx_impl a1b a1) (return 0)
                                         })
                            (\<lambda>(a1b, a2b). doM {
                                  x \<leftarrow> ll_sub a2b 1;
                                  (a1c, a2c) \<leftarrow> eo_extract_impl a1b x;
                                  x \<leftarrow> array_upd a2c a2b a1c;
                                  xa \<leftarrow> ll_sub a2b 1;
                                  return (x, xa)
                                })
                            (x, xa);
             x \<leftarrow> array_upd a1b a2b a1;
             xa \<leftarrow> ll_sub bi a2b;
             return (xa, x)
           })
          (return (0, ai))
       }
    M_CONST unat_sort.maybe_is_insert_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> ll_icmp_slt bia bi;
         x \<leftarrow> llc_if x (ll_sub bi 1 \<bind> unat_sort.cmpo_idxs_impl ai bi) (return 0);
         llc_if x
          (doM {
             (a1, a2) \<leftarrow> eo_extract_impl ai bi;
             x \<leftarrow> ll_sub bi 1;
             (a1a, a2a) \<leftarrow> eo_extract_impl a2 x;
             x \<leftarrow> array_upd a2a bi a1a;
             xa \<leftarrow> ll_sub bi 1;
             (a1b, a2b) \<leftarrow> llc_while (\<lambda>(a1b, a2b). doM {
                                           x \<leftarrow> ll_icmp_slt bia a2b;
                                           llc_if x (ll_sub a2b 1 \<bind> unat_sort.cmpo_v_idx_impl a1b a1) (return 0)
                                         })
                            (\<lambda>(a1b, a2b). doM {
                                  x \<leftarrow> ll_sub a2b 1;
                                  (a1c, a2c) \<leftarrow> eo_extract_impl a1b x;
                                  x \<leftarrow> array_upd a2c a2b a1c;
                                  xa \<leftarrow> ll_sub a2b 1;
                                  return (x, xa)
                                })
                            (x, xa);
             x \<leftarrow> array_upd a1b a2b a1;
             xa \<leftarrow> ll_sub bi a2b;
             return (xa, x)
           })
          (return (0, ai))
       }
    M_CONST str_sort.SAMPLE_SORT.mop_seth_impl \<equiv> \<lambda>ai bic bib bia bi. doM {
                                                       x \<leftarrow> ll_add ai bia;
                                                       array_upd bib x bi
                                                     }
    M_CONST str_sort.SAMPLE_SORT.mop_geth_impl \<equiv> \<lambda>ai bib bia bi. ll_add ai bi \<bind> eo_extract_impl bia
    M_CONST str_sort.qsp_next_l_impl \<equiv> \<lambda>ai bib bia bi. llc_while (\<lambda>s. str_sort.cmp_idxs_impl ai s bib) (\<lambda>s. ll_add s 1) bia
    M_CONST unat_sort.qsp_next_l_impl \<equiv> \<lambda>ai bib bia bi. llc_while (\<lambda>s. unat_sort.cmp_idxs_impl ai s bib) (\<lambda>s. ll_add s 1) bia
    M_CONST str_sort.qsp_next_h_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (str_sort.cmp_idxs_impl ai bia) (\<lambda>s. ll_sub s 1)
    M_CONST unat_sort.qsp_next_h_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (unat_sort.cmp_idxs_impl ai bia) (\<lambda>s. ll_sub s 1)
    M_CONST str_sort.pdq_insort_impl \<equiv> \<lambda>ai bib bia bi. llc_if ai (str_sort.pdq_guarded_insort_impl bib bia bi) (str_sort.pdq_unguarded_insort_impl bib bia bi)
    M_CONST unat_sort.pdq_insort_impl \<equiv> \<lambda>ai bib bia bi. llc_if ai (unat_sort.pdq_guarded_insort_impl bib bia bi) (unat_sort.pdq_unguarded_insort_impl bib bia bi)
    M_CONST str_sort.right_first_find_prev_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                        x \<leftarrow> ll_add bib 1;
                                                        x \<leftarrow> ll_icmp_eq bia x;
                                                        llc_if x (str_sort.right_find_prev_g_impl ai bib bi) (str_sort.right_find_prev_ug_impl ai bib bi)
                                                      }
    M_CONST unat_sort.right_first_find_prev_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                         x \<leftarrow> ll_add bib 1;
                                                         x \<leftarrow> ll_icmp_eq bia x;
                                                         llc_if x (unat_sort.right_find_prev_g_impl ai bib bi) (unat_sort.right_find_prev_ug_impl ai bib bi)
                                                       }
    M_CONST str_sort.left_first_find_next_impl \<equiv> \<lambda>ai bic bib bia bi. doM {
                                                       x \<leftarrow> ll_add bib 1;
                                                       x \<leftarrow> ll_icmp_eq x bia;
                                                       llc_if x (str_sort.left_find_next_g_impl ai bic bia bi) (str_sort.left_find_next_ug_impl ai bic bia bi)
                                                     }
    M_CONST unat_sort.left_first_find_next_impl \<equiv> \<lambda>ai bic bib bia bi. doM {
                                                        x \<leftarrow> ll_add bib 1;
                                                        x \<leftarrow> ll_icmp_eq x bia;
                                                        llc_if x (unat_sort.left_find_next_g_impl ai bic bia bi) (unat_sort.left_find_next_ug_impl ai bic bia bi)
                                                      }
    M_CONST str_sort.move_pivot_to_front_impl \<equiv> \<lambda>ai bia bi. doM {
                                                      x \<leftarrow> snat_sub_impl bi bia;
                                                      xa \<leftarrow> snat_div_impl x 2;
                                                      x \<leftarrow> ll_icmp_slt 0x80 x;
                                                      llc_if x (doM {
                                                                  x \<leftarrow> ll_add bia xa;
                                                                  xb \<leftarrow> ll_sub bi 1;
                                                                  x \<leftarrow> str_sort.sort_three_impl ai bia x xb;
                                                                  xb \<leftarrow> ll_add bia 1;
                                                                  xc \<leftarrow> ll_add bia xa;
                                                                  xc \<leftarrow> ll_sub xc 1;
                                                                  xd \<leftarrow> ll_sub bi 2;
                                                                  x \<leftarrow> str_sort.sort_three_impl x xb xc xd;
                                                                  xb \<leftarrow> ll_add bia 2;
                                                                  xc \<leftarrow> ll_add bia xa;
                                                                  xc \<leftarrow> ll_add xc 1;
                                                                  xd \<leftarrow> ll_sub bi 3;
                                                                  x \<leftarrow> str_sort.sort_three_impl x xb xc xd;
                                                                  xb \<leftarrow> ll_add bia xa;
                                                                  xb \<leftarrow> ll_sub xb 1;
                                                                  xc \<leftarrow> ll_add bia xa;
                                                                  xd \<leftarrow> ll_add bia xa;
                                                                  xd \<leftarrow> ll_add xd 1;
                                                                  x \<leftarrow> str_sort.sort_three_impl x xb xc xd;
                                                                  ll_add bia xa \<bind> swap_eos_impl x bia
                                                                })
                                                       (doM {
                                                          x \<leftarrow> ll_add bia xa;
                                                          ll_sub bi 1 \<bind> str_sort.sort_three_impl ai x bia
                                                        })
                                                    }
    M_CONST unat_sort.move_pivot_to_front_impl \<equiv> \<lambda>ai bia bi. doM {
                                                       x \<leftarrow> snat_sub_impl bi bia;
                                                       xa \<leftarrow> snat_div_impl x 2;
                                                       x \<leftarrow> ll_icmp_slt 0x80 x;
                                                       llc_if x (doM {
                                                                   x \<leftarrow> ll_add bia xa;
                                                                   xb \<leftarrow> ll_sub bi 1;
                                                                   x \<leftarrow> unat_sort.sort_three_impl ai bia x xb;
                                                                   xb \<leftarrow> ll_add bia 1;
                                                                   xc \<leftarrow> ll_add bia xa;
                                                                   xc \<leftarrow> ll_sub xc 1;
                                                                   xd \<leftarrow> ll_sub bi 2;
                                                                   x \<leftarrow> unat_sort.sort_three_impl x xb xc xd;
                                                                   xb \<leftarrow> ll_add bia 2;
                                                                   xc \<leftarrow> ll_add bia xa;
                                                                   xc \<leftarrow> ll_add xc 1;
                                                                   xd \<leftarrow> ll_sub bi 3;
                                                                   x \<leftarrow> unat_sort.sort_three_impl x xb xc xd;
                                                                   xb \<leftarrow> ll_add bia xa;
                                                                   xb \<leftarrow> ll_sub xb 1;
                                                                   xc \<leftarrow> ll_add bia xa;
                                                                   xd \<leftarrow> ll_add bia xa;
                                                                   xd \<leftarrow> ll_add xd 1;
                                                                   x \<leftarrow> unat_sort.sort_three_impl x xb xc xd;
                                                                   ll_add bia xa \<bind> swap_eos_impl x bia
                                                                 })
                                                        (doM {
                                                           x \<leftarrow> ll_add bia xa;
                                                           ll_sub bi 1 \<bind> unat_sort.sort_three_impl ai x bia
                                                         })
                                                     }
    M_CONST str_sort.right_find_prev_ug_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (\<lambda>s. doM {
     x \<leftarrow> str_sort.cmp_idxs_impl ai s bia;
     ll_add x 1
   })
                                                                             (\<lambda>s. ll_sub s 1)
    M_CONST unat_sort.right_find_prev_ug_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (\<lambda>s. doM {
      x \<leftarrow> unat_sort.cmp_idxs_impl ai s bia;
      ll_add x 1
    })
                                                                              (\<lambda>s. ll_sub s 1)
    M_CONST str_sort.right_find_next_ug_impl \<equiv> \<lambda>ai bib bia bi. ll_add bi 1 \<bind> llc_while (\<lambda>s. str_sort.cmp_idxs_impl ai s bib) (\<lambda>s. ll_add s 1)
    M_CONST unat_sort.right_find_next_ug_impl \<equiv> \<lambda>ai bib bia bi. ll_add bi 1 \<bind> llc_while (\<lambda>s. unat_sort.cmp_idxs_impl ai s bib) (\<lambda>s. ll_add s 1)
    M_CONST str_sort.right_find_prev_g_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (\<lambda>s. doM {
    x \<leftarrow> ll_add bia 1;
    x \<leftarrow> ll_icmp_slt x s;
    llc_if x (doM {
                x \<leftarrow> str_sort.cmp_idxs_impl ai s bia;
                ll_add x 1
              })
     (return 0)
  })
                                                                            (\<lambda>s. ll_sub s 1)
    M_CONST unat_sort.right_find_prev_g_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (\<lambda>s. doM {
     x \<leftarrow> ll_add bia 1;
     x \<leftarrow> ll_icmp_slt x s;
     llc_if x (doM {
                 x \<leftarrow> unat_sort.cmp_idxs_impl ai s bia;
                 ll_add x 1
               })
      (return 0)
   })
                                                                             (\<lambda>s. ll_sub s 1)
    M_CONST str_sort.left_find_prev_ug_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (str_sort.cmp_idxs_impl ai bia) (\<lambda>s. ll_sub s 1)
    M_CONST unat_sort.left_find_prev_ug_impl \<equiv> \<lambda>ai bia bi. ll_sub bi 1 \<bind> llc_while (unat_sort.cmp_idxs_impl ai bia) (\<lambda>s. ll_sub s 1)
    M_CONST str_sort.left_find_next_ug_impl \<equiv> \<lambda>ai bib bia bi. ll_add bi 1 \<bind> llc_while (\<lambda>s. doM {
        x \<leftarrow> str_sort.cmp_idxs_impl ai bib s;
        ll_add x 1
      })
                                                                                (\<lambda>s. ll_add s 1)
    M_CONST unat_sort.left_find_next_ug_impl \<equiv> \<lambda>ai bib bia bi. ll_add bi 1 \<bind> llc_while (\<lambda>s. doM {
         x \<leftarrow> unat_sort.cmp_idxs_impl ai bib s;
         ll_add x 1
       })
                                                                                 (\<lambda>s. ll_add s 1)
    M_CONST unat_sort.cmp_idxs'_impl \<equiv> \<lambda>ai bia bi. doM {
                                             x \<leftarrow> array_nth ai bia;
                                             array_nth ai bi \<bind> ll_icmp_ult x
                                           }
    M_CONST str_sort.left_find_next_g_impl \<equiv> \<lambda>ai bib bia bi. ll_add bi 1 \<bind> llc_while (\<lambda>s. doM {
       x \<leftarrow> ll_sub bia 1;
       x \<leftarrow> ll_icmp_slt s x;
       llc_if x (doM {
                   x \<leftarrow> str_sort.cmp_idxs_impl ai bib s;
                   ll_add x 1
                 })
        (return 0)
     })
                                                                               (\<lambda>s. ll_add s 1)
    M_CONST unat_sort.left_find_next_g_impl \<equiv> \<lambda>ai bib bia bi. ll_add bi 1 \<bind> llc_while (\<lambda>s. doM {
        x \<leftarrow> ll_sub bia 1;
        x \<leftarrow> ll_icmp_slt s x;
        llc_if x (doM {
                    x \<leftarrow> unat_sort.cmp_idxs_impl ai bib s;
                    ll_add x 1
                  })
         (return 0)
      })
                                                                                (\<lambda>s. ll_add s 1)
    M_CONST str_sort.partition_right_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> str_sort.right_find_next_ug_impl ai bia bi bia;
         xa \<leftarrow> str_sort.right_first_find_prev_impl ai bia x bi;
         xb \<leftarrow> ll_icmp_sle xa x;
         (a1, a1a, a2a) \<leftarrow> llc_while (\<lambda>(a1, x, y). ll_icmp_slt x y) (\<lambda>(a1, a1a, a2a). doM {
                                                                          x \<leftarrow> swap_eos_impl a1 a1a a2a;
                                                                          xa \<leftarrow> str_sort.right_find_next_ug_impl x bia bi a1a;
                                                                          xb \<leftarrow> str_sort.right_find_prev_ug_impl x bia a2a;
                                                                          return (x, xa, xb)
                                                                        })
                            (ai, x, xa);
         x \<leftarrow> ll_sub a1a 1;
         x \<leftarrow> ll_icmp_ne bia x;
         x \<leftarrow> llc_if x (ll_sub a1a 1 \<bind> swap_eos_impl a1 bia) (return a1);
         xa \<leftarrow> ll_sub a1a 1;
         return (xb, xa, x)
       }
    M_CONST unat_sort.partition_right_impl \<equiv>
    \<lambda>ai bia bi. doM {
         x \<leftarrow> unat_sort.right_find_next_ug_impl ai bia bi bia;
         xa \<leftarrow> unat_sort.right_first_find_prev_impl ai bia x bi;
         xb \<leftarrow> ll_icmp_sle xa x;
         (a1, a1a, a2a) \<leftarrow> llc_while (\<lambda>(a1, x, y). ll_icmp_slt x y) (\<lambda>(a1, a1a, a2a). doM {
                                                                          x \<leftarrow> swap_eos_impl a1 a1a a2a;
                                                                          xa \<leftarrow> unat_sort.right_find_next_ug_impl x bia bi a1a;
                                                                          xb \<leftarrow> unat_sort.right_find_prev_ug_impl x bia a2a;
                                                                          return (x, xa, xb)
                                                                        })
                            (ai, x, xa);
         x \<leftarrow> ll_sub a1a 1;
         x \<leftarrow> ll_icmp_ne bia x;
         x \<leftarrow> llc_if x (ll_sub a1a 1 \<bind> swap_eos_impl a1 bia) (return a1);
         xa \<leftarrow> ll_sub a1a 1;
         return (xb, xa, x)
       }
    M_CONST snat.am2_contains_key \<equiv> \<lambda>ai bi. doM {
                                          x \<leftarrow> array_nth bi ai;
                                          xa \<leftarrow> ll_icmp_eq (- 1) x;
                                          r \<leftarrow> ll_add xa 1;
                                          snat.free_option (\<lambda>_. return ()) x;
                                          return r
                                        }
    M_CONST str_sort.cmpo_v_idx_impl \<equiv> \<lambda>ai bia bi. doM {
                                             (a1, a2) \<leftarrow> eo_extract_impl ai bi;
                                             x \<leftarrow> strcmp_impl bia a1;
                                             array_upd a2 bi a1;
                                             return x
                                           }
    M_CONST unat_sort.cmpo_v_idx_impl \<equiv> \<lambda>ai bia bi. doM {
                                              (a1, a2) \<leftarrow> eo_extract_impl ai bi;
                                              x \<leftarrow> ll_icmp_ult bia a1;
                                              array_upd a2 bi a1;
                                              return x
                                            }
    M_CONST str_sort.cmpo_idx_v_impl \<equiv> \<lambda>ai bia bi. doM {
                                             (a1, a2) \<leftarrow> eo_extract_impl ai bia;
                                             x \<leftarrow> strcmp_impl a1 bi;
                                             array_upd a2 bia a1;
                                             return x
                                           }
    M_CONST unat_sort.cmpo_idx_v_impl \<equiv> \<lambda>ai bia bi. doM {
                                              (a1, a2) \<leftarrow> eo_extract_impl ai bia;
                                              x \<leftarrow> ll_icmp_ult a1 bi;
                                              array_upd a2 bia a1;
                                              return x
                                            }
    M_CONST str_sort.cmpo_idxs_impl \<equiv> \<lambda>ai bia bi. doM {
                                            (a1, a2) \<leftarrow> eo_extract_impl ai bia;
                                            (a1a, a2a) \<leftarrow> eo_extract_impl a2 bi;
                                            x \<leftarrow> strcmp_impl a1 a1a;
                                            xa \<leftarrow> array_upd a2a bia a1;
                                            array_upd xa bi a1a;
                                            return x
                                          }
    M_CONST unat_sort.cmpo_idxs_impl \<equiv> \<lambda>ai bia bi. doM {
                                             (a1, a2) \<leftarrow> eo_extract_impl ai bia;
                                             (a1a, a2a) \<leftarrow> eo_extract_impl a2 bi;
                                             x \<leftarrow> ll_icmp_ult a1 a1a;
                                             xa \<leftarrow> array_upd a2a bia a1;
                                             array_upd xa bi a1a;
                                             return x
                                           }
    M_CONST str_sort.pdqsort_aux_impl \<equiv>
    \<lambda>ai bic bib bia bi.
       Monad.REC
        (\<lambda>cf (a1, a1a, a1b, a1c, a2c). doM {
              x \<leftarrow> ll_sub a1c a1b;
              x \<leftarrow> ll_icmp_slt x pdq_is_threshold;
              llc_if x (str_sort.pdq_insort_impl a1 a1a a1b a1c)
               (doM {
                  x \<leftarrow> str_sort.move_pivot_to_front_impl a1a a1b a1c;
                  xa \<leftarrow> llc_if a1 (return 0) (doM {
                                                xa \<leftarrow> ll_sub a1b 1;
                                                x \<leftarrow> str_sort.cmp_idxs_impl x xa a1b;
                                                ll_add x 1
                                              });
                  llc_if xa (doM {
                               (a1d, a1e, a2e) \<leftarrow> str_sort.partition_left_impl x a1b a1c;
                               x \<leftarrow> ll_add a1e 1;
                               cf (0, a2e, x, a1c, a2c)
                             })
                   (doM {
                      (a1d, a1e, a2e) \<leftarrow> str_sort.partition_right_impl x a1b a1c;
                      (a1f, a2f) \<leftarrow> str_sort.shuffle_impl a2e a1b a1c a1e;
                      x \<leftarrow> llc_if a1f (ll_sub a2c 1) (return a2c);
                      xa \<leftarrow> ll_icmp_eq x 0;
                      (a1g, a2g) \<leftarrow>
                        llc_if xa (doM {
                                     x \<leftarrow> str_sort.heapsort_impl a2f a1b a1c;
                                     return (1, x)
                                   })
                         (doM {
                            x \<leftarrow> ll_add a1f 1;
                            x \<leftarrow> ll_and a1d x;
                            llc_if x (doM {
                                        (a1g, a2g) \<leftarrow> str_sort.maybe_insort_impl a2f a1b a1e;
                                        llc_if a1g (doM {
                                                      x \<leftarrow> ll_add a1e 1;
                                                      str_sort.maybe_insort_impl a2g x a1c
                                                    })
                                         (return (0, a2g))
                                      })
                             (return (0, a2f))
                          });
                      llc_if a1g (return a2g) (doM {
                                                 xa \<leftarrow> cf (a1, a2g, a1b, a1e, x);
                                                 xb \<leftarrow> ll_add a1e 1;
                                                 cf (0, xa, xb, a1c, x)
                                               })
                    })
                })
            })
        (ai, bic, bib, bia, bi)
    M_CONST unat_sort.pdqsort_aux_impl \<equiv>
    \<lambda>ai bic bib bia bi.
       Monad.REC
        (\<lambda>cf (a1, a1a, a1b, a1c, a2c). doM {
              x \<leftarrow> ll_sub a1c a1b;
              x \<leftarrow> ll_icmp_slt x pdq_is_threshold;
              llc_if x (unat_sort.pdq_insort_impl a1 a1a a1b a1c)
               (doM {
                  x \<leftarrow> unat_sort.move_pivot_to_front_impl a1a a1b a1c;
                  xa \<leftarrow> llc_if a1 (return 0) (doM {
                                                xa \<leftarrow> ll_sub a1b 1;
                                                x \<leftarrow> unat_sort.cmp_idxs_impl x xa a1b;
                                                ll_add x 1
                                              });
                  llc_if xa (doM {
                               (a1d, a1e, a2e) \<leftarrow> unat_sort.partition_left_impl x a1b a1c;
                               x \<leftarrow> ll_add a1e 1;
                               cf (0, a2e, x, a1c, a2c)
                             })
                   (doM {
                      (a1d, a1e, a2e) \<leftarrow> unat_sort.partition_right_impl x a1b a1c;
                      (a1f, a2f) \<leftarrow> unat_sort.shuffle_impl a2e a1b a1c a1e;
                      x \<leftarrow> llc_if a1f (ll_sub a2c 1) (return a2c);
                      xa \<leftarrow> ll_icmp_eq x 0;
                      (a1g, a2g) \<leftarrow>
                        llc_if xa (doM {
                                     x \<leftarrow> unat_sort.heapsort_impl a2f a1b a1c;
                                     return (1, x)
                                   })
                         (doM {
                            x \<leftarrow> ll_add a1f 1;
                            x \<leftarrow> ll_and a1d x;
                            llc_if x (doM {
                                        (a1g, a2g) \<leftarrow> unat_sort.maybe_insort_impl a2f a1b a1e;
                                        llc_if a1g (doM {
                                                      x \<leftarrow> ll_add a1e 1;
                                                      unat_sort.maybe_insort_impl a2g x a1c
                                                    })
                                         (return (0, a2g))
                                      })
                             (return (0, a2f))
                          });
                      llc_if a1g (return a2g) (doM {
                                                 xa \<leftarrow> cf (a1, a2g, a1b, a1e, x);
                                                 xb \<leftarrow> ll_add a1e 1;
                                                 cf (0, xa, xb, a1c, x)
                                               })
                    })
                })
            })
        (ai, bic, bib, bia, bi)
    M_CONST str_sort.cmp_idxs_impl \<equiv> \<lambda>ai bia bi. doM {
                                           (a1, a2) \<leftarrow> eo_extract_impl ai bia;
                                           (a1a, a2a) \<leftarrow> eo_extract_impl a2 bi;
                                           x \<leftarrow> strcmp_impl a1 a1a;
                                           xa \<leftarrow> array_upd a2a bia a1;
                                           array_upd xa bi a1a;
                                           return x
                                         }
    M_CONST unat_sort.cmp_idxs_impl \<equiv> \<lambda>ai bia bi. doM {
                                            (a1, a2) \<leftarrow> eo_extract_impl ai bia;
                                            (a1a, a2a) \<leftarrow> eo_extract_impl a2 bi;
                                            x \<leftarrow> ll_icmp_ult a1 a1a;
                                            xa \<leftarrow> array_upd a2a bia a1;
                                            array_upd xa bi a1a;
                                            return x
                                          }
    M_CONST str_sort.sort_three_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                             x \<leftarrow> str_sort.cmp_idxs_impl ai bia bib;
                                             x \<leftarrow> llc_if x (swap_eos_impl ai bib bia) (return ai);
                                             xa \<leftarrow> str_sort.cmp_idxs_impl x bi bia;
                                             x \<leftarrow> llc_if xa (swap_eos_impl x bia bi) (return x);
                                             xa \<leftarrow> str_sort.cmp_idxs_impl x bia bib;
                                             llc_if xa (swap_eos_impl x bib bia) (return x)
                                           }
    M_CONST unat_sort.sort_three_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                              x \<leftarrow> unat_sort.cmp_idxs_impl ai bia bib;
                                              x \<leftarrow> llc_if x (swap_eos_impl ai bib bia) (return ai);
                                              xa \<leftarrow> unat_sort.cmp_idxs_impl x bi bia;
                                              x \<leftarrow> llc_if xa (swap_eos_impl x bia bi) (return x);
                                              xa \<leftarrow> unat_sort.cmp_idxs_impl x bia bib;
                                              llc_if xa (swap_eos_impl x bib bia) (return x)
                                            }
    M_CONST snat.am2_update \<equiv> \<lambda>ai bia bi. doM {
                                    r \<leftarrow> array_upd bi ai bia;
                                    snat.free_option (\<lambda>_. return ()) bia;
                                    return r
                                  }
    M_CONST snat.am2_delete \<equiv> \<lambda>ai bi. doM {
                                    r \<leftarrow> array_upd bi ai (- 1);
                                    snat.free_option (\<lambda>_. return ()) (- 1);
                                    return r
                                  }
    M_CONST str_sort.SAMPLE_SORT.pcmpo_v_idx_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                          (a1, a2) \<leftarrow> eo_extract_impl bib bi;
                                                          x \<leftarrow> str_sort.SAMPLE_SORT.idx_pcmp_impl ai bia a1;
                                                          array_upd a2 bi a1;
                                                          return x
                                                        }
    M_CONST unat_sort.SAMPLE_SORT.pcmpo_v_idx_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                           (a1, a2) \<leftarrow> eo_extract_impl bib bi;
                                                           x \<leftarrow> unat_sort.SAMPLE_SORT.idx_pcmp_impl ai bia a1;
                                                           array_upd a2 bi a1;
                                                           return x
                                                         }
    M_CONST str_sort.SAMPLE_SORT.pcmpo_idx_v_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                          (a1, a2) \<leftarrow> eo_extract_impl bib bia;
                                                          x \<leftarrow> str_sort.SAMPLE_SORT.idx_pcmp_impl ai a1 bi;
                                                          array_upd a2 bia a1;
                                                          return x
                                                        }
    M_CONST unat_sort.SAMPLE_SORT.pcmpo_idx_v_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                           (a1, a2) \<leftarrow> eo_extract_impl bib bia;
                                                           x \<leftarrow> unat_sort.SAMPLE_SORT.idx_pcmp_impl ai a1 bi;
                                                           array_upd a2 bia a1;
                                                           return x
                                                         }
    M_CONST str_sort.SAMPLE_SORT.pcmpo_idxs_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                         (a1, a2) \<leftarrow> eo_extract_impl bib bia;
                                                         (a1a, a2a) \<leftarrow> eo_extract_impl a2 bi;
                                                         x \<leftarrow> str_sort.SAMPLE_SORT.idx_pcmp_impl ai a1 a1a;
                                                         xa \<leftarrow> array_upd a2a bia a1;
                                                         array_upd xa bi a1a;
                                                         return x
                                                       }
    M_CONST unat_sort.SAMPLE_SORT.pcmpo_idxs_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                          (a1, a2) \<leftarrow> eo_extract_impl bib bia;
                                                          (a1a, a2a) \<leftarrow> eo_extract_impl a2 bi;
                                                          x \<leftarrow> unat_sort.SAMPLE_SORT.idx_pcmp_impl ai a1 a1a;
                                                          xa \<leftarrow> array_upd a2a bia a1;
                                                          array_upd xa bi a1a;
                                                          return x
                                                        }
    M_CONST str_sort.SAMPLE_SORT.qsp_next_l_impl \<equiv> \<lambda>ai bic bib bia bi. llc_while (\<lambda>s. str_sort.SAMPLE_SORT.pcmp_idxs_impl ai bic s bib) (\<lambda>s. ll_add s 1) bia
    M_CONST unat_sort.SAMPLE_SORT.qsp_next_l_impl \<equiv> \<lambda>ai bic bib bia bi. llc_while (\<lambda>s. unat_sort.SAMPLE_SORT.pcmp_idxs_impl ai bic s bib) (\<lambda>s. ll_add s 1) bia
    M_CONST str_sort.SAMPLE_SORT.qsp_next_h_impl \<equiv> \<lambda>ai bib bia bi. ll_sub bi 1 \<bind> llc_while (str_sort.SAMPLE_SORT.pcmp_idxs_impl ai bib bia) (\<lambda>s. ll_sub s 1)
    M_CONST unat_sort.SAMPLE_SORT.qsp_next_h_impl \<equiv> \<lambda>ai bib bia bi. ll_sub bi 1 \<bind> llc_while (unat_sort.SAMPLE_SORT.pcmp_idxs_impl ai bib bia) (\<lambda>s. ll_sub s 1)
    M_CONST str_sort.SAMPLE_SORT.pcmp_idxs_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                        x \<leftarrow> return bib;
                                                        xa \<leftarrow> str_sort.SAMPLE_SORT.pcmpo_idxs_impl ai x bia bi;
                                                        return x;
                                                        return xa
                                                      }
    M_CONST unat_sort.SAMPLE_SORT.pcmp_idxs_impl \<equiv> \<lambda>ai bib bia bi. doM {
                                                         x \<leftarrow> return bib;
                                                         xa \<leftarrow> unat_sort.SAMPLE_SORT.pcmpo_idxs_impl ai x bia bi;
                                                         return x;
                                                         return xa
                                                       }
    return (~~ ?x) \<equiv> ll_add ?x 1
    return (ll_ne_null ?a1) \<equiv> ll_ptrcmp_ne ?a1 null
    return (ll_eq_null ?a1) \<equiv> ll_ptrcmp_eq ?a1 null
    return (?a1 xor ?b1) \<equiv> ll_xor ?a1 ?b1
    return (?a1 && ?b1) \<equiv> ll_and ?a1 ?b1
    return (?a1 || ?b1) \<equiv> ll_or ?a1 ?b1
    return (case ?x1 of (a, b) \<Rightarrow> ?f1 a b) \<equiv> case ?x1 of (a, b) \<Rightarrow> return (?f1 a b)
    return (ll_cmp'_ult ?a1 ?b1) \<equiv> ll_icmp_ult ?a1 ?b1
    return (ll_cmp'_ule ?a1 ?b1) \<equiv> ll_icmp_ule ?a1 ?b1
    return (ll_cmp'_slt ?a1 ?b1) \<equiv> ll_icmp_slt ?a1 ?b1
    return (ll_cmp'_sle ?a1 ?b1) \<equiv> ll_icmp_sle ?a1 ?b1
    return (ll_cmp'_ne ?a1 ?b1) \<equiv> ll_icmp_ne ?a1 ?b1
    return (ll_cmp'_eq ?a1 ?b1) \<equiv> ll_icmp_eq ?a1 ?b1
    return (?a1 * ?b1) \<equiv> ll_mul ?a1 ?b1
    return (?a1 - ?b1) \<equiv> ll_sub ?a1 ?b1
    return (?a1 + ?b1) \<equiv> ll_add ?a1 ?b1
    return (?a1, ?b1) \<equiv> doM {
      x \<leftarrow> prod_insert_fst init ?a1;
      prod_insert_snd x ?b1 \<bind> return
    }
    (\<And>x. ?a = x \<Longrightarrow> PROP ?P x) \<equiv> PROP ?P ?a
    (\<And>x. x = ?a \<Longrightarrow> PROP ?P x) \<equiv> PROP ?P ?a
    (\<And>x. PROP ?V) \<equiv> PROP ?V
    Num.BitM num.One \<equiv> num.One
    Num.BitM (num.Bit1 ?n1) \<equiv> num.Bit1 (num.Bit0 ?n1)
    Num.BitM (num.Bit0 ?n1) \<equiv> num.Bit1 (Num.BitM ?n1)
    THE x. x = ?y \<equiv> ?y
    THE y. ?y = y \<equiv> ?y
    \<not> False \<equiv> True
    \<not> True \<equiv> False
    \<not> \<not> ?y \<equiv> ?y
    \<not> (\<forall>x. ?P1 x) \<equiv> \<exists>x. \<not> ?P1 x
    \<nexists>x. ?P1 x \<equiv> \<forall>x. \<not> ?P1 x
    \<not> (?P1 \<longrightarrow> ?Q1) \<equiv> ?P1 \<and> \<not> ?Q1
    \<not> (?P1 \<or> ?Q1) \<equiv> \<not> ?P1 \<and> \<not> ?Q1
    \<not> (?P1 \<and> ?Q1) \<equiv> \<not> ?P1 \<or> \<not> ?Q1
    ?P1 \<noteq> ?Q1 \<equiv> ?P1 = (\<not> ?Q1)
    \<forall>x. ?t1 \<noteq> x \<equiv> False
    \<forall>x. x \<noteq> ?t1 \<equiv> False
    \<forall>x. ?t1 = x \<longrightarrow> ?P1 x \<equiv> ?P1 ?t1
    \<forall>x. x = ?t1 \<longrightarrow> ?P1 x \<equiv> ?P1 ?t1
    \<forall>x. ?y \<equiv> ?y
    \<forall>x. ?P1 \<longrightarrow> ?Q1 x \<equiv> ?P1 \<longrightarrow> (\<forall>x. ?Q1 x)
    \<forall>x. ?P1 x \<longrightarrow> ?Q1 \<equiv> (\<exists>x. ?P1 x) \<longrightarrow> ?Q1
    \<forall>x. ?P1 \<or> ?Q1 x \<equiv> ?P1 \<or> (\<forall>x. ?Q1 x)
    \<forall>x. ?P1 x \<or> ?Q1 \<equiv> (\<forall>x. ?P1 x) \<or> ?Q1
    \<forall>x. ?P1 \<and> ?Q1 x \<equiv> ?P1 \<and> (\<forall>x. ?Q1 x)
    \<forall>x. ?P1 x \<and> ?Q1 \<equiv> (\<forall>x. ?P1 x) \<and> ?Q1
    \<exists>x. ?t1 = x \<and> ?P1 x \<equiv> ?P1 ?t1
    \<exists>x. x = ?t1 \<and> ?P1 x \<equiv> ?P1 ?t1
    \<exists>x. x = ?t1 \<equiv> True
    \<exists>x. ?y \<equiv> ?y
    \<exists>x. ?P1 \<longrightarrow> ?Q1 x \<equiv> ?P1 \<longrightarrow> (\<exists>x. ?Q1 x)
    \<exists>x. ?P1 x \<longrightarrow> ?Q1 \<equiv> (\<forall>x. ?P1 x) \<longrightarrow> ?Q1
    \<exists>x. ?P1 \<or> ?Q1 x \<equiv> ?P1 \<or> (\<exists>x. ?Q1 x)
    \<exists>x. ?P1 x \<or> ?Q1 \<equiv> (\<exists>x. ?P1 x) \<or> ?Q1
    \<exists>x. ?P1 \<and> ?Q1 x \<equiv> ?P1 \<and> (\<exists>x. ?Q1 x)
    \<exists>x. ?P1 x \<and> ?Q1 \<equiv> (\<exists>x. ?P1 x) \<and> ?Q1
    \<exists>x. ?t1 = x \<equiv> True
    arl_aux_compute_size ?c ?c' \<equiv> doM {
      max \<leftarrow> ll_max_snat;
      max \<leftarrow> ll_udiv max (signed_nat 2);
      b \<leftarrow> ll_icmp_ule ?c max;
      llc_if b (doM {
                  c \<leftarrow> ll_mul ?c (signed_nat 2);
                  cok \<leftarrow> ll_icmp_sle ?c' c;
                  llc_if cok (return c) (return ?c')
                })
       (return ?c')
    }
    arl_ensure_capacity ?c' ?al \<equiv> doM {
      let (l, c, a) = ?al;
      cok \<leftarrow> ll_icmp_sle ?c' c;
      llc_if cok (return (l, c, a)) (arl_resize ?c' (l, c, a))
    }
    prod_insert_snd ?p ?x \<equiv> ll_insert_value ?p ?x 1
    prod_insert_fst ?p ?x \<equiv> ll_insert_value ?p ?x 0
    eo_extract_impl ?p ?i \<equiv> doM {
      r \<leftarrow> array_nth ?p ?i;
      return (r, ?p)
    }
    arl_push_back' ?al ?x \<equiv> doM {
      let (l, c, a) = ?al;
      array_upd a l ?x;
      l \<leftarrow> ll_add l (signed_nat 1);
      return (l, c, a)
    }
    arl_push_back ?al ?x \<equiv> doM {
      l \<leftarrow> arl_len ?al;
      l \<leftarrow> ll_add l (signed_nat 1);
      al \<leftarrow> arl_ensure_capacity l ?al;
      arl_push_back' al ?x
    }
    unat_unat_downcast TYPE(?'a) ?x \<equiv> ll_trunc ?x TYPE(?'a word)
    snat_unat_downcast TYPE(?'a) ?x \<equiv> ll_trunc ?x TYPE(?'a word)
    snat_snat_downcast TYPE(?'a) ?x \<equiv> ll_trunc ?x TYPE(?'a word)
    aal_pop_back ?na ?i \<equiv> doM {
      let (n, a) = ?na;
      aa \<leftarrow> nao_nth a ?i;
      (r, aa) \<leftarrow> arl_pop_back aa;
      a \<leftarrow> nao_upd a ?i aa;
      return (r, n, a)
    }
    llc_while_annot ?I ?R \<equiv> llc_while
    arl_new_repl ?n ?x \<equiv> doM {
      a \<leftarrow> narray_new_init ?n ?x;
      return (?n, ?n, a)
    }
    unat_unat_upcast TYPE(?'a) ?x \<equiv> ll_zext ?x TYPE(?'a word)
    unat_snat_upcast TYPE(?'a) ?x \<equiv> ll_zext ?x TYPE(?'a word)
    snat_snat_upcast TYPE(?'a) ?x \<equiv> ll_zext ?x TYPE(?'a word)
    nao_rejoin ?a ?i \<equiv> return ()
    arl_new_sz TYPE(?'a) ?n \<equiv> arl_new_sz_raw ?n
    aal_llen ?na ?i \<equiv> doM {
      let (n, a) = ?na;
      aa \<leftarrow> nao_nth a ?i;
      r \<leftarrow> arl_len aa;
      nao_rejoin a ?i;
      return r
    }
    arl_take ?l' ?al \<equiv> let (l, c, a) = ?al in return (?l', c, a)
    nao_nth ?a ?i \<equiv> array_nth ?a ?i
    nao_new TYPE(?'a) ?n \<equiv> narray_new TYPE(?'a) ?n
    ll_cmp'_ne null ?b1 \<equiv> ll_ne_null ?b1
    ll_cmp'_ne ?a1 null \<equiv> ll_ne_null ?a1
    ll_cmp'_eq null ?b1 \<equiv> ll_eq_null ?b1
    ll_cmp'_eq ?a1 null \<equiv> ll_eq_null ?a1
    arl_nth ?al ?i \<equiv> let (l, c, a) = ?al in array_nth a ?i
    arl_new TYPE(?'a) TYPE(?'l) \<equiv> arl_new_raw
    neg_numeral_class.sub num.One num.One \<equiv> 0
    neg_numeral_class.sub num.One (num.Bit1 ?l1) \<equiv> - numeral (num.Bit0 ?l1)
    neg_numeral_class.sub num.One (num.Bit0 ?l1) \<equiv> - numeral (Num.BitM ?l1)
    neg_numeral_class.sub (num.Bit1 ?k1) num.One \<equiv> numeral (num.Bit0 ?k1)
    neg_numeral_class.sub (num.Bit1 ?k1) (num.Bit1 ?l1) \<equiv> neg_numeral_class.dbl (neg_numeral_class.sub ?k1 ?l1)
    neg_numeral_class.sub (num.Bit1 ?k1) (num.Bit0 ?l1) \<equiv> neg_numeral_class.dbl_inc (neg_numeral_class.sub ?k1 ?l1)
    neg_numeral_class.sub (num.Bit0 ?k1) num.One \<equiv> numeral (Num.BitM ?k1)
    neg_numeral_class.sub (num.Bit0 ?k1) (num.Bit1 ?l1) \<equiv> neg_numeral_class.dbl_dec (neg_numeral_class.sub ?k1 ?l1)
    neg_numeral_class.sub (num.Bit0 ?k1) (num.Bit0 ?l1) \<equiv> neg_numeral_class.dbl (neg_numeral_class.sub ?k1 ?l1)
    narray_new TYPE(?'a) ?n \<equiv> if ?n = signed_nat 0 then return null else array_new TYPE(?'a) ?n
    0 * ?a1 \<equiv> 0
    num.One * ?y \<equiv> ?y
    ?a1 * 0 \<equiv> 0
    ?y * num.One \<equiv> ?y
    - numeral ?m1 * - numeral ?n1 \<equiv> numeral (?m1 * ?n1)
    - numeral ?m1 * numeral ?n1 \<equiv> - numeral (?m1 * ?n1)
    numeral ?m1 * - numeral ?n1 \<equiv> - numeral (?m1 * ?n1)
    numeral ?m1 * numeral ?n1 \<equiv> numeral (?m1 * ?n1)
    num.Bit1 ?m1 * num.Bit1 ?n1 \<equiv> num.Bit1 (?m1 + ?n1 + num.Bit0 (?m1 * ?n1))
    num.Bit1 ?m1 * num.Bit0 ?n1 \<equiv> num.Bit0 (num.Bit1 ?m1 * ?n1)
    num.Bit0 ?m1 * num.Bit1 ?n1 \<equiv> num.Bit0 (?m1 * num.Bit1 ?n1)
    num.Bit0 ?m1 * num.Bit0 ?n1 \<equiv> num.Bit0 (num.Bit0 (?m1 * ?n1))
    0 - ?a1 \<equiv> - ?a1
    1 - 1 \<equiv> 0
    1 - - 1 \<equiv> 2
    1 - - numeral ?n1 \<equiv> numeral (num.One + ?n1)
    1 - numeral ?n1 \<equiv> neg_numeral_class.sub num.One ?n1
    ?y - 0 \<equiv> ?y
    - 1 - 1 \<equiv> - 2
    - 1 - - 1 \<equiv> 0
    - 1 - - numeral ?n1 \<equiv> neg_numeral_class.sub ?n1 num.One
    - 1 - numeral ?n1 \<equiv> - numeral (Num.inc ?n1)
    - numeral ?m1 - 1 \<equiv> - numeral (?m1 + num.One)
    - numeral ?m1 - - 1 \<equiv> neg_numeral_class.sub num.One ?m1
    - numeral ?m1 - - numeral ?n1 \<equiv> neg_numeral_class.sub ?n1 ?m1
    - numeral ?m1 - numeral ?n1 \<equiv> - numeral (?m1 + ?n1)
    numeral ?m1 - 1 \<equiv> neg_numeral_class.sub ?m1 num.One
    numeral ?m1 - - 1 \<equiv> numeral (Num.inc ?m1)
    numeral ?m1 - - numeral ?n1 \<equiv> numeral (?m1 + ?n1)
    numeral ?m1 - numeral ?n1 \<equiv> neg_numeral_class.sub ?m1 ?n1
    ?a1 ^ 0 \<equiv> 1
    ?a1 ^ numeral ?k1 \<equiv> ?a1 * ?a1 ^ pred_numeral ?k1
    array_nth ?a ?i \<equiv> ll_ofs_ptr ?a ?i \<bind> ll_load
    array_new TYPE(?'a) ?n \<equiv> ll_malloc TYPE(?'a) ?n
    0 + ?y \<equiv> ?y
    1 + 1 \<equiv> 2
    1 + - 1 \<equiv> 0
    1 + - numeral ?m1 \<equiv> neg_numeral_class.sub num.One ?m1
    1 + numeral ?n1 \<equiv> numeral (num.One + ?n1)
    num.One + num.One \<equiv> num.Bit0 num.One
    num.One + num.Bit1 ?n1 \<equiv> num.Bit0 (?n1 + num.One)
    num.One + num.Bit0 ?n1 \<equiv> num.Bit1 ?n1
    ?y + 0 \<equiv> ?y
    - 1 + 1 \<equiv> 0
    - 1 + - 1 \<equiv> - 2
    - 1 + - numeral ?n1 \<equiv> - numeral (Num.inc ?n1)
    - 1 + numeral ?n1 \<equiv> neg_numeral_class.sub ?n1 num.One
    - numeral ?m1 + 1 \<equiv> neg_numeral_class.sub num.One ?m1
    - numeral ?m1 + - 1 \<equiv> - numeral (Num.inc ?m1)
    - numeral ?m1 + - numeral ?n1 \<equiv> - (numeral ?m1 + numeral ?n1)
    - numeral ?m1 + numeral ?n1 \<equiv> neg_numeral_class.sub ?n1 ?m1
    numeral ?n1 + 1 \<equiv> numeral (?n1 + num.One)
    numeral ?m1 + - 1 \<equiv> neg_numeral_class.sub ?m1 num.One
    numeral ?m1 + - numeral ?n1 \<equiv> neg_numeral_class.sub ?m1 ?n1
    numeral ?m1 + numeral ?n1 \<equiv> numeral (?m1 + ?n1)
    num.Bit1 ?m1 + num.One \<equiv> num.Bit0 (?m1 + num.One)
    num.Bit1 ?m1 + num.Bit1 ?n1 \<equiv> num.Bit0 (?m1 + ?n1 + num.One)
    num.Bit1 ?m1 + num.Bit0 ?n1 \<equiv> num.Bit1 (?m1 + ?n1)
    num.Bit0 ?m1 + num.One \<equiv> num.Bit1 ?m1
    num.Bit0 ?m1 + num.Bit1 ?n1 \<equiv> num.Bit1 (?m1 + ?n1)
    num.Bit0 ?m1 + num.Bit0 ?n1 \<equiv> num.Bit0 (?m1 + ?n1)
    ars_split ?i ?p \<equiv> doM {
      p\<^sub>2 \<leftarrow> ll_ofs_ptr ?p ?i;
      return (?p, p\<^sub>2)
    }
    ars_join ?p\<^sub>1 ?p\<^sub>2 \<equiv> return ?p\<^sub>1
    False \<longrightarrow> ?P1 \<equiv> True
    True \<longrightarrow> ?y \<equiv> ?y
    ?P1 \<longrightarrow> False \<equiv> \<not> ?P1
    ?P1 \<longrightarrow> True \<equiv> True
    ?P1 \<longrightarrow> ?P1 \<equiv> True
    ?P1 \<longrightarrow> \<not> ?P1 \<equiv> \<not> ?P1
    ?P1 \<or> ?Q1 \<longrightarrow> ?R1 \<equiv> (?P1 \<longrightarrow> ?R1) \<and> (?Q1 \<longrightarrow> ?R1)
    ?y \<bind> return \<equiv> ?y
    ll_const ?x1 \<bind> ?f1 \<equiv> ?f1 ?x1
    return ?f1 \<bind> ?m1 \<equiv> ?m1 ?f1
    (?m1 \<bind> ?f1) \<bind> ?g1 \<equiv> doM {
      x \<leftarrow> ?m1;
      ?f1 x \<bind> ?g1
    }
    doM {
      x \<leftarrow> ll_insert_value init ?a1 0;
      x \<leftarrow> ll_insert_value x ?b1 Numeral1;
      a \<leftarrow> ll_extract_value x 0;
      ll_extract_value x Numeral1 \<bind> ?f1 a
    } \<equiv> ?f1 ?a1 ?b1
    (PROP ?P \<Longrightarrow> True) \<equiv> True
    (False \<Longrightarrow> ?P) \<equiv> True
    (True \<Longrightarrow> PROP ?P) \<equiv> PROP ?P
    False \<or> ?y \<equiv> ?y
    True \<or> ?P1 \<equiv> True
    ?y \<or> False \<equiv> ?y
    ?P1 \<or> True \<equiv> True
    ?y \<or> ?y \<equiv> ?y
    ?P1 \<or> \<not> ?P1 \<equiv> True
    ?Q1 \<or> (?P1 \<longrightarrow> ?R1) \<equiv> ?P1 \<longrightarrow> ?Q1 \<or> ?R1
    ?P1 \<or> ?P1 \<or> ?Q1 \<equiv> ?P1 \<or> ?Q1
    \<not> ?P1 \<or> ?P1 \<equiv> True
    \<not> ?P1 \<or> ?Q1 \<equiv> ?P1 \<longrightarrow> ?Q1
    (?P1 \<longrightarrow> ?Q1) \<or> ?R1 \<equiv> ?P1 \<longrightarrow> ?Q1 \<or> ?R1
    (?P1 \<or> ?Q1) \<or> ?R1 \<equiv> ?P1 \<or> ?Q1 \<or> ?R1
    False \<and> ?P1 \<equiv> False
    True \<and> ?y \<equiv> ?y
    ?P1 \<and> False \<equiv> False
    ?y \<and> True \<equiv> ?y
    ?y \<and> ?y \<equiv> ?y
    ?P1 \<and> \<not> ?P1 \<equiv> False
    ?P1 \<and> ?P1 \<and> ?Q1 \<equiv> ?P1 \<and> ?Q1
    \<not> ?P1 \<and> ?P1 \<equiv> False
    (?P1 \<longrightarrow> ?y) \<and> (\<not> ?P1 \<longrightarrow> ?y) \<equiv> ?y
    (?P1 \<and> ?Q1) \<and> ?R1 \<equiv> ?P1 \<and> ?Q1 \<and> ?R1
    False = ?P1 \<equiv> \<not> ?P1
    True = ?y \<equiv> ?y
    ?P1 = False \<equiv> \<not> ?P1
    ?y = True \<equiv> ?y
    ?x1 = ?x1 \<equiv> True
    ?P1 = (\<not> ?P1) \<equiv> False
    (\<not> ?P1) = ?P1 \<equiv> False
    (\<not> ?P1) = (\<not> ?Q1) \<equiv> ?P1 = ?Q1
    ars_with_split_nores ?i ?a ?m \<equiv> doM {
      (a\<^sub>1, a\<^sub>2) \<leftarrow> ars_split ?i ?a;
      (uu_, uu_) \<leftarrow> ?m a\<^sub>1 a\<^sub>2;
      ars_join a\<^sub>1 a\<^sub>2;
      return ?a
    }
    aal_push_back ?na ?i ?x \<equiv> doM {
      let (n, a) = ?na;
      aa \<leftarrow> nao_nth a ?i;
      aa \<leftarrow> arl_push_back aa ?x;
      a \<leftarrow> nao_upd a ?i aa;
      return (n, a)
    }
    lift_cmp_op ?c ?a ?b \<equiv> from_bool (?c ?a ?b)
    nao_free ?free ?a ?len \<equiv> doM {
      llc_while (\<lambda>i. ll_icmp_slt i ?len) (\<lambda>i. doM {
                                                x \<leftarrow> nao_nth ?a i;
                                                ?free x;
                                                ll_add i (signed_nat 1) \<bind> return
                                              })
       (signed_nat 0);
      nao_open ?a;
      narray_free ?a
    }
    aal_take ?na ?i ?l \<equiv> doM {
      let (n, a) = ?na;
      aa \<leftarrow> nao_nth a ?i;
      aa \<leftarrow> arl_take ?l aa;
      a \<leftarrow> nao_upd a ?i aa;
      return (n, a)
    }
    nao_upd ?a ?i ?x \<equiv> array_upd ?a ?i ?x
    aal_idx ?na ?i ?j \<equiv> doM {
      let (n, a) = ?na;
      aa \<leftarrow> nao_nth a ?i;
      r \<leftarrow> arl_nth aa ?j;
      nao_rejoin a ?i;
      return r
    }
    arl_upd ?al ?i ?x \<equiv> doM {
      let (l, c, a) = ?al;
      array_upd a ?i ?x;
      return (l, c, a)
    }
    ars_with_split ?i ?a ?m \<equiv> doM {
      (a\<^sub>1, a\<^sub>2) \<leftarrow> ars_split ?i ?a;
      (r, uu_, uu_) \<leftarrow> ?m a\<^sub>1 a\<^sub>2;
      ars_join a\<^sub>1 a\<^sub>2;
      return (r, ?a)
    }
    array_upd ?a ?i ?x \<equiv> doM {
      p \<leftarrow> ll_ofs_ptr ?a ?i;
      ll_store ?x p;
      return ?a
    }
    M_CONST snat.free_option ?fr ?c \<equiv> doM {
      d \<leftarrow> ll_icmp_eq (- 1) ?c;
      llc_if d (return ()) (?fr ?c)
    }
    if False then ?x1 else ?y \<equiv> ?y
    if True then ?y else ?y1 \<equiv> ?y
    if ?b1 then ?t1 else ?e1 \<equiv> llc_if (from_bool ?b1) ?t1 ?e1
    if ?c1 then ?y else ?y \<equiv> ?y
    if ?y = ?y1 then ?y1 else ?y \<equiv> ?y
    aal_upd ?na ?i ?j ?x \<equiv> doM {
      let (n, a) = ?na;
      aa \<leftarrow> nao_nth a ?i;
      aa \<leftarrow> arl_upd aa ?j ?x;
      a \<leftarrow> nao_upd a ?i aa;
      return (n, a)
    }
    Sorting_Setup.swap_eo_impl ?to_eo_impl ?to_wo_impl ?extract_impl ?set_impl \<equiv> \<lambda>ai bia bi. doM {
                                                                                       x \<leftarrow> ?to_eo_impl ai;
(a1, a2) \<leftarrow> ?extract_impl x bia;
(a1a, a2a) \<leftarrow> ?extract_impl a2 bi;
x \<leftarrow> ?set_impl a2a bia a1a;
?set_impl x bi a1 \<bind> ?to_wo_impl
                                                                                     }
simplification procedures:
  HOL.defined_All:
      \<forall>x. ?P x
  defined_Ex:
      \<exists>x. ?P x
  defined_all:
      \<And>x. PROP ?P x
  eliminate_false_implies:
      False \<Longrightarrow> PROP ?P
  let_simp:
      Let ?x ?f
  neq:
      ?x = ?y
congruences:
  (\<longrightarrow>): \<lbrakk>?P \<equiv> ?P'; ?P' \<Longrightarrow> ?Q \<equiv> ?Q'\<rbrakk> \<Longrightarrow> ?P \<longrightarrow> ?Q \<equiv> ?P' \<longrightarrow> ?Q'
  (=simp=>): \<lbrakk>PROP ?P \<equiv> PROP ?P'; PROP ?P' \<Longrightarrow> PROP ?Q \<equiv> PROP ?Q'\<rbrakk> \<Longrightarrow> (PROP ?P =simp=> PROP ?Q) \<equiv> (PROP ?P' =simp=> PROP ?Q')
  M_CONST: M_CONST ?c \<equiv> M_CONST ?c
  dflt_option.free_option: dflt_option.free_option ?uu \<equiv> dflt_option.free_option ?uu
  dflt_option_private.free_option: dflt_option_private.free_option ?uu \<equiv> dflt_option_private.free_option ?uu
loopers: "split HOL.If :: (HOL.bool, (_, (_, _)fun)fun)fun"
unsafe solvers: "HOL unsafe"
safe solvers: "HOL safe"