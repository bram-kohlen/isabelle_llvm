; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"






define i64 @Sorting_Log2_word_clz_impl(i64 %x) {

  start:
    %x1 = icmp eq i64 %x, 0
    br i1 %x1, label %then, label %else

  then:
    br label %ctd_if

  else:
    %x2 = call i64 @Sorting_Log2_word_clz_impl1 (i64 %x)
    br label %ctd_if

  ctd_if:
    %x3 = phi i64 [ %x2, %else ], [ 64, %then ]
    ret i64 %x3
}

define i64 @Sorting_Log2_word_clz_impl1(i64 %x) {

  start:
    %x1 = insertvalue { i64, i64 } zeroinitializer, i64 0, 0
    %xa = insertvalue { i64, i64 } %x1, i64 %x, 1
    br label %while_start

  while_start:
    %xb = phi { i64, i64 } [ %x4, %while_body ], [ %xa, %start ]
    %a1 = extractvalue { i64, i64 } %xb, 0
    %x2 = extractvalue { i64, i64 } %xb, 1
    %x3 = icmp slt i64 0, %x2
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, i64 } %xb, 0
    %a2 = extractvalue { i64, i64 } %xb, 1
    %xaa = add i64 %a11, 1
    %xba = shl i64 %a2, 1
    %xca = insertvalue { i64, i64 } zeroinitializer, i64 %xaa, 0
    %x4 = insertvalue { i64, i64 } %xca, i64 %xba, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, i64 } %xb, 0
    %a21 = extractvalue { i64, i64 } %xb, 1
    ret i64 %a12
}

define i64* @heapsort(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = sub i64 %x2, %x1
    %xa = icmp slt i64 1, %x3
    br i1 %xa, label %then, label %else

  then:
    %xb = call i64* @Sorting_Introsort_elem_sort_heapify_btu_impl (i64 %x1, i64 %x2, i64* %x)
    %xc = insertvalue { i64*, i64 } zeroinitializer, i64* %xb, 0
    %xd = insertvalue { i64*, i64 } %xc, i64 %x2, 1
    br label %while_start

  while_start:
    %xca = phi { i64*, i64 } [ %x5, %while_body ], [ %xd, %then ]
    %a1 = extractvalue { i64*, i64 } %xca, 0
    %a2 = extractvalue { i64*, i64 } %xca, 1
    %xda = add i64 %x1, 1
    %x4 = icmp slt i64 %xda, %a2
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xca, 0
    %a21 = extractvalue { i64*, i64 } %xca, 1
    %xda1 = sub i64 %a21, 1
    %xea = getelementptr i64, i64* %a11, i64 %x1
    %xf = load i64, i64* %xea
    %xg = getelementptr i64, i64* %a11, i64 %xda1
    %xh = load i64, i64* %xg
    %p = getelementptr i64, i64* %a11, i64 %x1
    store i64 %xh, i64* %p
    %pa = getelementptr i64, i64* %a11, i64 %xda1
    store i64 %xf, i64* %pa
    %xka = sub i64 %a21, 1
    %xl = call i64* @Sorting_Introsort_elem_sort_sift_down_impl (i64 %x1, i64 %xka, i64 %x1, i64* %a11)
    %xma = sub i64 %a21, 1
    %xn = insertvalue { i64*, i64 } zeroinitializer, i64* %xl, 0
    %x5 = insertvalue { i64*, i64 } %xn, i64 %xma, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xca, 0
    %a22 = extractvalue { i64*, i64 } %xca, 1
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x6 = phi i64* [ %x, %else ], [ %a12, %while_end ]
    ret i64* %x6
}

define i64* @introsort(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = sub i64 %x2, %x1
    %xa = icmp slt i64 1, %x3
    br i1 %xa, label %then, label %else

  then:
    %xb = sub i64 %x2, %x1
    %xc = sub i64 64, 1
    %xd = call i64 @Sorting_Log2_word_clz_impl (i64 %xb)
    %xe = sub i64 %xc, %xd
    %xf = mul i64 %xe, 2
    %xg = call i64* @introsort_aux (i64* %x, i64 %x1, i64 %x2, i64 %xf)
    %x4 = call i64* @insertion_sort (i64* %xg, i64 %x1, i64 %x2)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x5 = phi i64* [ %x, %else ], [ %x4, %then ]
    ret i64* %x5
}

define i64* @Sorting_Introsort_elem_sort_is_insert_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = getelementptr i64, i64* %x, i64 %x2
    %xa = load i64, i64* %x3
    %xb = insertvalue { i64*, i64 } zeroinitializer, i64* %x, 0
    %xc = insertvalue { i64*, i64 } %xb, i64 %x2, 1
    br label %while_start

  while_start:
    %xba = phi { i64*, i64 } [ %x7, %while_body ], [ %xc, %start ]
    %a1 = extractvalue { i64*, i64 } %xba, 0
    %a2 = extractvalue { i64*, i64 } %xba, 1
    %xca = icmp slt i64 %x1, %a2
    br i1 %xca, label %then, label %else

  then:
    %xda = sub i64 %a2, 1
    %xe = getelementptr i64, i64* %a1, i64 %xda
    %x4 = load i64, i64* %xe
    %x5 = icmp ult i64 %xa, %x4
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x6 = phi i1 [ 0, %else ], [ %x5, %then ]
    br i1 %x6, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xba, 0
    %a21 = extractvalue { i64*, i64 } %xba, 1
    %xca1 = sub i64 %a21, 1
    %xda1 = getelementptr i64, i64* %a11, i64 %xca1
    %xe1 = load i64, i64* %xda1
    %p = getelementptr i64, i64* %a11, i64 %a21
    store i64 %xe1, i64* %p
    %xga = sub i64 %a21, 1
    %xh = insertvalue { i64*, i64 } zeroinitializer, i64* %a11, 0
    %x7 = insertvalue { i64*, i64 } %xh, i64 %xga, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xba, 0
    %a22 = extractvalue { i64*, i64 } %xba, 1
    %p1 = getelementptr i64, i64* %a12, i64 %a22
    store i64 %xa, i64* %p1
    ret i64* %a12
}

define i64* @Sorting_Introsort_elem_sort_sift_down_impl(i64 %x, i64 %x1, i64 %x2, i64* %x3) {

  start:
    %x4 = sub i64 %x2, %x
    %xa = add i64 %x, %x4
    %xb = getelementptr i64, i64* %x3, i64 %xa
    %xc = load i64, i64* %xb
    %xd = insertvalue { i64, i1 } zeroinitializer, i64 %x4, 0
    %tmpa = insertvalue { i64, i1 } %xd, i1 1, 1
    %xe = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %x3, 0
    %xf = insertvalue { i64*, { i64, i1 } } %xe, { i64, i1 } %tmpa, 1
    br label %while_start

  while_start:
    %xda = phi { i64*, { i64, i1 } } [ %x16, %ctd_if ], [ %xf, %start ]
    %a1 = extractvalue { i64*, { i64, i1 } } %xda, 0
    %xea = extractvalue { i64*, { i64, i1 } } %xda, 1
    %a1a = extractvalue { i64, i1 } %xea, 0
    %a2a = extractvalue { i64, i1 } %xea, 1
    %xfa = sub i64 %x1, %x
    %xga = sub i64 %xfa, 1
    %xha = udiv i64 %xga, 2
    %xi = icmp slt i64 %a1a, %xha
    %x5 = and i1 %xi, %a2a
    br i1 %x5, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, { i64, i1 } } %xda, 0
    %xea1 = extractvalue { i64*, { i64, i1 } } %xda, 1
    %a1a1 = extractvalue { i64, i1 } %xea1, 0
    %a2a1 = extractvalue { i64, i1 } %xea1, 1
    %xfa1 = mul i64 2, %a1a1
    %xga1 = add i64 %xfa1, 1
    %xh = mul i64 2, %a1a1
    %xia = add i64 %xh, 2
    %xj = add i64 %x, %xga1
    %xk = getelementptr i64, i64* %a11, i64 %xj
    %xl = load i64, i64* %xk
    %xm = add i64 %x, %xia
    %xn = getelementptr i64, i64* %a11, i64 %xm
    %xo = load i64, i64* %xn
    %xp = icmp ult i64 %xl, %xo
    br i1 %xp, label %then, label %else

  then:
    %xq = icmp ult i64 %xc, %xo
    br i1 %xq, label %thena, label %elsea

  thena:
    %xr = add i64 %x, %a1a1
    %p = getelementptr i64, i64* %a11, i64 %xr
    store i64 %xo, i64* %p
    %xt = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xu = insertvalue { i64, i1 } zeroinitializer, i64 %xia, 0
    %x6 = insertvalue { i64, i1 } %xu, i1 1, 1
    %x7 = insertvalue { i64*, { i64, i1 } } %xt, { i64, i1 } %x6, 1
    br label %ctd_ifa

  elsea:
    %xr1 = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xs = insertvalue { i64, i1 } zeroinitializer, i64 %a1a1, 0
    %x8 = insertvalue { i64, i1 } %xs, i1 0, 1
    %x9 = insertvalue { i64*, { i64, i1 } } %xr1, { i64, i1 } %x8, 1
    br label %ctd_ifa

  ctd_ifa:
    %x10 = phi { i64*, { i64, i1 } } [ %x9, %elsea ], [ %x7, %thena ]
    br label %ctd_if

  else:
    %xq1 = icmp ult i64 %xc, %xl
    br i1 %xq1, label %thenb, label %elseb

  thenb:
    %xr2 = add i64 %x, %a1a1
    %p1 = getelementptr i64, i64* %a11, i64 %xr2
    store i64 %xl, i64* %p1
    %xt1 = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xu1 = insertvalue { i64, i1 } zeroinitializer, i64 %xga1, 0
    %x11 = insertvalue { i64, i1 } %xu1, i1 1, 1
    %x12 = insertvalue { i64*, { i64, i1 } } %xt1, { i64, i1 } %x11, 1
    br label %ctd_ifb

  elseb:
    %xr3 = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xs1 = insertvalue { i64, i1 } zeroinitializer, i64 %a1a1, 0
    %x13 = insertvalue { i64, i1 } %xs1, i1 0, 1
    %x14 = insertvalue { i64*, { i64, i1 } } %xr3, { i64, i1 } %x13, 1
    br label %ctd_ifb

  ctd_ifb:
    %x15 = phi { i64*, { i64, i1 } } [ %x14, %elseb ], [ %x12, %thenb ]
    br label %ctd_if

  ctd_if:
    %x16 = phi { i64*, { i64, i1 } } [ %x15, %ctd_ifb ], [ %x10, %ctd_ifa ]
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, { i64, i1 } } %xda, 0
    %xea2 = extractvalue { i64*, { i64, i1 } } %xda, 1
    %a1a2 = extractvalue { i64, i1 } %xea2, 0
    %a2a2 = extractvalue { i64, i1 } %xea2, 1
    %xfa2 = sub i64 %x1, %x
    %xga2 = udiv i64 %xfa2, 2
    %xh1 = icmp slt i64 %a1a2, %xga2
    br i1 %xh1, label %thenc, label %elsec

  thenc:
    %xi1 = mul i64 2, %a1a2
    %xja = add i64 %xi1, 1
    %xk1 = add i64 %x, %xja
    %xl1 = getelementptr i64, i64* %a12, i64 %xk1
    %xm1 = load i64, i64* %xl1
    %xn1 = icmp ult i64 %xc, %xm1
    br i1 %xn1, label %thend, label %elsed

  thend:
    %xo1 = add i64 %x, %a1a2
    %p2 = getelementptr i64, i64* %a12, i64 %xo1
    store i64 %xm1, i64* %p2
    %xq2 = add i64 %x, %xja
    %pa = getelementptr i64, i64* %a12, i64 %xq2
    store i64 %xc, i64* %pa
    br label %ctd_ifd

  elsed:
    %xo2 = add i64 %x, %a1a2
    %p3 = getelementptr i64, i64* %a12, i64 %xo2
    store i64 %xc, i64* %p3
    br label %ctd_ifd

  ctd_ifd:
    %x17 = phi i64* [ %a12, %elsed ], [ %a12, %thend ]
    br label %ctd_ifc

  elsec:
    %xi2 = add i64 %x, %a1a2
    %p4 = getelementptr i64, i64* %a12, i64 %xi2
    store i64 %xc, i64* %p4
    br label %ctd_ifc

  ctd_ifc:
    %x18 = phi i64* [ %a12, %elsec ], [ %x17, %ctd_ifd ]
    ret i64* %x18
}

define i64* @Sorting_Introsort_elem_sort_heapify_btu_impl(i64 %x, i64 %x1, i64* %x2) {

  start:
    %xa = sub i64 %x1, 1
    %xb = insertvalue { i64*, i64 } zeroinitializer, i64* %x2, 0
    %xc = insertvalue { i64*, i64 } %xb, i64 %xa, 1
    br label %while_start

  while_start:
    %xaa = phi { i64*, i64 } [ %x5, %while_body ], [ %xc, %start ]
    %a1 = extractvalue { i64*, i64 } %xaa, 0
    %x3 = extractvalue { i64*, i64 } %xaa, 1
    %x4 = icmp slt i64 %x, %x3
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xaa, 0
    %a2 = extractvalue { i64*, i64 } %xaa, 1
    %xba = sub i64 %a2, 1
    %xca = call i64* @Sorting_Introsort_elem_sort_sift_down_impl (i64 %x, i64 %x1, i64 %xba, i64* %a11)
    %xda = insertvalue { i64*, i64 } zeroinitializer, i64* %xca, 0
    %x5 = insertvalue { i64*, i64 } %xda, i64 %xba, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xaa, 0
    %a21 = extractvalue { i64*, i64 } %xaa, 1
    ret i64* %a12
}

define i64* @insertion_sort(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = insertvalue { i64*, i64 } zeroinitializer, i64* %x, 0
    %xa = insertvalue { i64*, i64 } %x3, i64 %x1, 1
    br label %while_start

  while_start:
    %xb = phi { i64*, i64 } [ %x5, %while_body ], [ %xa, %start ]
    %a1 = extractvalue { i64*, i64 } %xb, 0
    %a2 = extractvalue { i64*, i64 } %xb, 1
    %x4 = icmp slt i64 %a2, %x2
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xb, 0
    %a21 = extractvalue { i64*, i64 } %xb, 1
    %xaa = call i64* @Sorting_Introsort_elem_sort_is_insert_impl (i64* %a11, i64 %x1, i64 %a21)
    %xba = add i64 %a21, 1
    %xca = insertvalue { i64*, i64 } zeroinitializer, i64* %xaa, 0
    %x5 = insertvalue { i64*, i64 } %xca, i64 %xba, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xb, 0
    %a22 = extractvalue { i64*, i64 } %xb, 1
    ret i64* %a12
}

define i64* @introsort_aux(i64* %x, i64 %x1, i64 %x2, i64 %x3) {

  start:
    %x4 = insertvalue { i64, i64 } zeroinitializer, i64 %x2, 0
    %tmpa = insertvalue { i64, i64 } %x4, i64 %x3, 1
    %xa = insertvalue { i64, { i64, i64 } } zeroinitializer, i64 %x1, 0
    %tmpab = insertvalue { i64, { i64, i64 } } %xa, { i64, i64 } %tmpa, 1
    %xb = insertvalue { i64*, { i64, { i64, i64 } } } zeroinitializer, i64* %x, 0
    %x5 = insertvalue { i64*, { i64, { i64, i64 } } } %xb, { i64, { i64, i64 } } %tmpab, 1
    %x6 = call i64* @Sorting_Introsort_elem_sort_introsort_qs_aux_impl_f_05685094 ({ i64*, { i64, { i64, i64 } } } %x5)
    ret i64* %x6
}

define i64* @Sorting_Introsort_elem_sort_introsort_qs_aux_impl_f_05685094({ i64*, { i64, { i64, i64 } } } %x) {

  start:
    %a1 = extractvalue { i64*, { i64, { i64, i64 } } } %x, 0
    %xaa = extractvalue { i64*, { i64, { i64, i64 } } } %x, 1
    %a1a = extractvalue { i64, { i64, i64 } } %xaa, 0
    %xba = extractvalue { i64, { i64, i64 } } %xaa, 1
    %a1b = extractvalue { i64, i64 } %xba, 0
    %a2b = extractvalue { i64, i64 } %xba, 1
    %xca = sub i64 %a1b, %a1a
    %xd = icmp slt i64 16, %xca
    br i1 %xd, label %then, label %else

  then:
    %xe = icmp slt i64 0, %a2b
    br i1 %xe, label %thena, label %elsea

  thena:
    %xf = sub i64 %a1b, %a1a
    %xga = udiv i64 %xf, 2
    %xh = add i64 %a1a, %xga
    %xia = add i64 %a1a, 1
    %xja = sub i64 %a1b, 1
    %xk = getelementptr i64, i64* %a1, i64 %xia
    %xl = load i64, i64* %xk
    %xm = getelementptr i64, i64* %a1, i64 %xh
    %xn = load i64, i64* %xm
    %xo = getelementptr i64, i64* %a1, i64 %xja
    %xp = load i64, i64* %xo
    %xq = icmp ult i64 %xl, %xn
    br i1 %xq, label %thenb, label %elseb

  thenb:
    %xr = icmp ult i64 %xn, %xp
    br i1 %xr, label %thenc, label %elsec

  thenc:
    %xs = getelementptr i64, i64* %a1, i64 %a1a
    %xt = load i64, i64* %xs
    %xu = getelementptr i64, i64* %a1, i64 %xh
    %xv = load i64, i64* %xu
    %p = getelementptr i64, i64* %a1, i64 %a1a
    store i64 %xv, i64* %p
    %pa = getelementptr i64, i64* %a1, i64 %xh
    store i64 %xt, i64* %pa
    br label %ctd_ifc

  elsec:
    %xs1 = icmp ult i64 %xl, %xp
    br i1 %xs1, label %thend, label %elsed

  thend:
    %xt1 = getelementptr i64, i64* %a1, i64 %a1a
    %xu1 = load i64, i64* %xt1
    %xv1 = getelementptr i64, i64* %a1, i64 %xja
    %xw = load i64, i64* %xv1
    %p1 = getelementptr i64, i64* %a1, i64 %a1a
    store i64 %xw, i64* %p1
    %pa1 = getelementptr i64, i64* %a1, i64 %xja
    store i64 %xu1, i64* %pa1
    br label %ctd_ifd

  elsed:
    %xt2 = getelementptr i64, i64* %a1, i64 %a1a
    %xu2 = load i64, i64* %xt2
    %xv2 = getelementptr i64, i64* %a1, i64 %xia
    %xw1 = load i64, i64* %xv2
    %p2 = getelementptr i64, i64* %a1, i64 %a1a
    store i64 %xw1, i64* %p2
    %pa2 = getelementptr i64, i64* %a1, i64 %xia
    store i64 %xu2, i64* %pa2
    br label %ctd_ifd

  ctd_ifd:
    %x1 = phi i64* [ %a1, %elsed ], [ %a1, %thend ]
    br label %ctd_ifc

  ctd_ifc:
    %x2 = phi i64* [ %x1, %ctd_ifd ], [ %a1, %thenc ]
    br label %ctd_ifb

  elseb:
    %xr1 = icmp ult i64 %xl, %xp
    br i1 %xr1, label %thene, label %elsee

  thene:
    %xs2 = getelementptr i64, i64* %a1, i64 %a1a
    %xt3 = load i64, i64* %xs2
    %xu3 = getelementptr i64, i64* %a1, i64 %xia
    %xv3 = load i64, i64* %xu3
    %p3 = getelementptr i64, i64* %a1, i64 %a1a
    store i64 %xv3, i64* %p3
    %pa3 = getelementptr i64, i64* %a1, i64 %xia
    store i64 %xt3, i64* %pa3
    br label %ctd_ife

  elsee:
    %xs3 = icmp ult i64 %xn, %xp
    br i1 %xs3, label %thenf, label %elsef

  thenf:
    %xt4 = getelementptr i64, i64* %a1, i64 %a1a
    %xu4 = load i64, i64* %xt4
    %xv4 = getelementptr i64, i64* %a1, i64 %xja
    %xw2 = load i64, i64* %xv4
    %p4 = getelementptr i64, i64* %a1, i64 %a1a
    store i64 %xw2, i64* %p4
    %pa4 = getelementptr i64, i64* %a1, i64 %xja
    store i64 %xu4, i64* %pa4
    br label %ctd_iff

  elsef:
    %xt5 = getelementptr i64, i64* %a1, i64 %a1a
    %xu5 = load i64, i64* %xt5
    %xv5 = getelementptr i64, i64* %a1, i64 %xh
    %xw3 = load i64, i64* %xv5
    %p5 = getelementptr i64, i64* %a1, i64 %a1a
    store i64 %xw3, i64* %p5
    %pa5 = getelementptr i64, i64* %a1, i64 %xh
    store i64 %xu5, i64* %pa5
    br label %ctd_iff

  ctd_iff:
    %x3 = phi i64* [ %a1, %elsef ], [ %a1, %thenf ]
    br label %ctd_ife

  ctd_ife:
    %x4 = phi i64* [ %x3, %ctd_iff ], [ %a1, %thene ]
    br label %ctd_ifb

  ctd_ifb:
    %xr2 = phi i64* [ %x4, %ctd_ife ], [ %x2, %ctd_ifc ]
    %xsa = add i64 %a1a, 1
    %xt6 = getelementptr i64, i64* %xr2, i64 %a1a
    %xu6 = load i64, i64* %xt6
    br label %while_start

  while_start:
    %s = phi i64 [ %x6, %while_body ], [ %xsa, %ctd_ifb ]
    %xv6 = getelementptr i64, i64* %xr2, i64 %s
    %xw4 = load i64, i64* %xv6
    %x5 = icmp ult i64 %xw4, %xu6
    br i1 %x5, label %while_body, label %while_end

  while_body:
    %x6 = add i64 %s, 1
    br label %while_start

  while_end:
    %xwa = sub i64 %a1b, 1
    br label %while_starta

  while_starta:
    %s1 = phi i64 [ %x9, %while_bodya ], [ %xwa, %while_end ]
    %xx = getelementptr i64, i64* %xr2, i64 %s1
    %x7 = load i64, i64* %xx
    %x8 = icmp ult i64 %xu6, %x7
    br i1 %x8, label %while_bodya, label %while_enda

  while_bodya:
    %x9 = sub i64 %s1, 1
    br label %while_starta

  while_enda:
    %xy = insertvalue { i64, i64 } zeroinitializer, i64 %s, 0
    %tmpda = insertvalue { i64, i64 } %xy, i64 %s1, 1
    %xz = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %xr2, 0
    %ya = insertvalue { i64*, { i64, i64 } } %xz, { i64, i64 } %tmpda, 1
    br label %while_startb

  while_startb:
    %xya = phi { i64*, { i64, i64 } } [ %x18, %while_endd ], [ %ya, %while_enda ]
    %a1c = extractvalue { i64*, { i64, i64 } } %xya, 0
    %xza = extractvalue { i64*, { i64, i64 } } %xya, 1
    %a = extractvalue { i64, i64 } %xza, 0
    %x10 = extractvalue { i64, i64 } %xza, 1
    %x11 = icmp slt i64 %a, %x10
    br i1 %x11, label %while_bodyb, label %while_endb

  while_bodyb:
    %a1c1 = extractvalue { i64*, { i64, i64 } } %xya, 0
    %xza1 = extractvalue { i64*, { i64, i64 } } %xya, 1
    %a1aa = extractvalue { i64, i64 } %xza1, 0
    %a2a = extractvalue { i64, i64 } %xza1, 1
    %yaa = getelementptr i64, i64* %a1c1, i64 %a1aa
    %yb = load i64, i64* %yaa
    %yc = getelementptr i64, i64* %a1c1, i64 %a2a
    %yd = load i64, i64* %yc
    %p6 = getelementptr i64, i64* %a1c1, i64 %a1aa
    store i64 %yd, i64* %p6
    %pa6 = getelementptr i64, i64* %a1c1, i64 %a2a
    store i64 %yb, i64* %pa6
    %yga = add i64 %a1aa, 1
    br label %while_startc

  while_startc:
    %s2 = phi i64 [ %x13, %while_bodyc ], [ %yga, %while_bodyb ]
    %yh = getelementptr i64, i64* %a1c1, i64 %s2
    %yi = load i64, i64* %yh
    %x12 = icmp ult i64 %yi, %xu6
    br i1 %x12, label %while_bodyc, label %while_endc

  while_bodyc:
    %x13 = add i64 %s2, 1
    br label %while_startc

  while_endc:
    %yia = sub i64 %a2a, 1
    br label %while_startd

  while_startd:
    %s3 = phi i64 [ %x16, %while_bodyd ], [ %yia, %while_endc ]
    %yj = getelementptr i64, i64* %a1c1, i64 %s3
    %x14 = load i64, i64* %yj
    %x15 = icmp ult i64 %xu6, %x14
    br i1 %x15, label %while_bodyd, label %while_endd

  while_bodyd:
    %x16 = sub i64 %s3, 1
    br label %while_startd

  while_endd:
    %yk = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %a1c1, 0
    %yl = insertvalue { i64, i64 } zeroinitializer, i64 %s2, 0
    %x17 = insertvalue { i64, i64 } %yl, i64 %s3, 1
    %x18 = insertvalue { i64*, { i64, i64 } } %yk, { i64, i64 } %x17, 1
    br label %while_startb

  while_endb:
    %a1c2 = extractvalue { i64*, { i64, i64 } } %xya, 0
    %xza2 = extractvalue { i64*, { i64, i64 } } %xya, 1
    %a1aa1 = extractvalue { i64, i64 } %xza2, 0
    %a2a1 = extractvalue { i64, i64 } %xza2, 1
    %yaa1 = insertvalue { i64*, i64 } zeroinitializer, i64* %a1c2, 0
    %yb1 = insertvalue { i64*, i64 } %yaa1, i64 %a1aa1, 1
    %a2 = extractvalue { i64*, i64 } %yb1, 0
    %b = extractvalue { i64*, i64 } %yb1, 1
    %yc1 = insertvalue { i64*, i64 } zeroinitializer, i64* %a2, 0
    %yd1 = insertvalue { i64*, i64 } %yc1, i64 %b, 1
    %a1ca = extractvalue { i64*, i64 } %yd1, 0
    %a2c = extractvalue { i64*, i64 } %yd1, 1
    %yea = sub i64 %a2b, 1
    %yf = insertvalue { i64, i64 } zeroinitializer, i64 %a1b, 0
    %tmpga = insertvalue { i64, i64 } %yf, i64 %yea, 1
    %yg = insertvalue { i64, { i64, i64 } } zeroinitializer, i64 %a2c, 0
    %tmpha = insertvalue { i64, { i64, i64 } } %yg, { i64, i64 } %tmpga, 1
    %yh2 = insertvalue { i64*, { i64, { i64, i64 } } } zeroinitializer, i64* %a1ca, 0
    %yi1 = insertvalue { i64*, { i64, { i64, i64 } } } %yh2, { i64, { i64, i64 } } %tmpha, 1
    %yfa = call i64* @Sorting_Introsort_elem_sort_introsort_qs_aux_impl_f_05685094 ({ i64*, { i64, { i64, i64 } } } %yi1)
    %yga1 = sub i64 %a2b, 1
    %yk1 = insertvalue { i64, i64 } zeroinitializer, i64 %a2c, 0
    %tmpib = insertvalue { i64, i64 } %yk1, i64 %yga1, 1
    %yl1 = insertvalue { i64, { i64, i64 } } zeroinitializer, i64 %a1a, 0
    %tmpja = insertvalue { i64, { i64, i64 } } %yl1, { i64, i64 } %tmpib, 1
    %ym = insertvalue { i64*, { i64, { i64, i64 } } } zeroinitializer, i64* %yfa, 0
    %x19 = insertvalue { i64*, { i64, { i64, i64 } } } %ym, { i64, { i64, i64 } } %tmpja, 1
    %x20 = call i64* @Sorting_Introsort_elem_sort_introsort_qs_aux_impl_f_05685094 ({ i64*, { i64, { i64, i64 } } } %x19)
    br label %ctd_ifa

  elsea:
    %x21 = call i64* @heapsort (i64* %a1, i64 %a1a, i64 %a1b)
    br label %ctd_ifa

  ctd_ifa:
    %x22 = phi i64* [ %x21, %elsea ], [ %x20, %while_endb ]
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x23 = phi i64* [ %a1, %else ], [ %x22, %ctd_ifa ]
    ret i64* %x23
}
