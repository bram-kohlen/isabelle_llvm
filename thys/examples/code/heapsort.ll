; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"






define i64* @IICF_Array_array_swap(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = getelementptr i64, i64* %x, i64 %x1
    %x4 = load i64, i64* %x3
    %x5 = getelementptr i64, i64* %x, i64 %x2
    %x6 = load i64, i64* %x5
    %p = getelementptr i64, i64* %x, i64 %x1
    store i64 %x6, i64* %p
    %p1 = getelementptr i64, i64* %x, i64 %x2
    store i64 %x4, i64* %p1
    ret i64* %x
}

define i64* @heapsort(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = sub i64 %x2, %x1
    %xa = icmp slt i64 1, %x3
    br i1 %xa, label %then, label %else

  then:
    %xb = call i64* @Sorting_Heapsort_heapsort_interp_heapify_btu_impl (i64 %x1, i64 %x2, i64* %x)
    %xc = insertvalue { i64*, i64 } zeroinitializer, i64* %xb, 0
    %xd = insertvalue { i64*, i64 } %xc, i64 %x2, 1
    br label %while_start

  while_start:
    %xca = phi { i64*, i64 } [ %x5, %while_body ], [ %xd, %then ]
    %a1 = extractvalue { i64*, i64 } %xca, 0
    %a2 = extractvalue { i64*, i64 } %xca, 1
    %xda = add i64 %x1, 1
    %x4 = icmp slt i64 %xda, %a2
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xca, 0
    %a21 = extractvalue { i64*, i64 } %xca, 1
    %xda1 = sub i64 %a21, 1
    %xea = call i64* @IICF_Array_array_swap (i64* %a11, i64 %x1, i64 %xda1)
    %xfa = sub i64 %a21, 1
    %xg = call i64* @Sorting_Heapsort_heapsort_interp_sift_down_impl (i64 %x1, i64 %xfa, i64 %x1, i64* %xea)
    %xha = sub i64 %a21, 1
    %xi = insertvalue { i64*, i64 } zeroinitializer, i64* %xg, 0
    %x5 = insertvalue { i64*, i64 } %xi, i64 %xha, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xca, 0
    %a22 = extractvalue { i64*, i64 } %xca, 1
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x6 = phi i64* [ %x, %else ], [ %a12, %while_end ]
    ret i64* %x6
}

define i64* @Sorting_Heapsort_heapsort_interp_sift_down_impl(i64 %x, i64 %x1, i64 %x2, i64* %x3) {

  start:
    %x4 = sub i64 %x2, %x
    %xa = add i64 %x, %x4
    %xb = getelementptr i64, i64* %x3, i64 %xa
    %xc = load i64, i64* %xb
    %xd = insertvalue { i64, i1 } zeroinitializer, i64 %x4, 0
    %tmpa = insertvalue { i64, i1 } %xd, i1 1, 1
    %xe = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %x3, 0
    %xf = insertvalue { i64*, { i64, i1 } } %xe, { i64, i1 } %tmpa, 1
    br label %while_start

  while_start:
    %xda = phi { i64*, { i64, i1 } } [ %x16, %ctd_if ], [ %xf, %start ]
    %a1 = extractvalue { i64*, { i64, i1 } } %xda, 0
    %xea = extractvalue { i64*, { i64, i1 } } %xda, 1
    %a1a = extractvalue { i64, i1 } %xea, 0
    %a2a = extractvalue { i64, i1 } %xea, 1
    %xfa = sub i64 %x1, %x
    %xga = sub i64 %xfa, 1
    %xha = udiv i64 %xga, 2
    %xi = icmp slt i64 %a1a, %xha
    %x5 = and i1 %xi, %a2a
    br i1 %x5, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, { i64, i1 } } %xda, 0
    %xea1 = extractvalue { i64*, { i64, i1 } } %xda, 1
    %a1a1 = extractvalue { i64, i1 } %xea1, 0
    %a2a1 = extractvalue { i64, i1 } %xea1, 1
    %xfa1 = mul i64 2, %a1a1
    %xga1 = add i64 %xfa1, 1
    %xh = mul i64 2, %a1a1
    %xia = add i64 %xh, 2
    %xj = add i64 %x, %xga1
    %xk = getelementptr i64, i64* %a11, i64 %xj
    %xl = load i64, i64* %xk
    %xm = add i64 %x, %xia
    %xn = getelementptr i64, i64* %a11, i64 %xm
    %xo = load i64, i64* %xn
    %xp = icmp ult i64 %xl, %xo
    br i1 %xp, label %then, label %else

  then:
    %xq = icmp ult i64 %xc, %xo
    br i1 %xq, label %thena, label %elsea

  thena:
    %xr = add i64 %x, %a1a1
    %p = getelementptr i64, i64* %a11, i64 %xr
    store i64 %xo, i64* %p
    %xt = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xu = insertvalue { i64, i1 } zeroinitializer, i64 %xia, 0
    %x6 = insertvalue { i64, i1 } %xu, i1 1, 1
    %x7 = insertvalue { i64*, { i64, i1 } } %xt, { i64, i1 } %x6, 1
    br label %ctd_ifa

  elsea:
    %xr1 = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xs = insertvalue { i64, i1 } zeroinitializer, i64 %a1a1, 0
    %x8 = insertvalue { i64, i1 } %xs, i1 0, 1
    %x9 = insertvalue { i64*, { i64, i1 } } %xr1, { i64, i1 } %x8, 1
    br label %ctd_ifa

  ctd_ifa:
    %x10 = phi { i64*, { i64, i1 } } [ %x9, %elsea ], [ %x7, %thena ]
    br label %ctd_if

  else:
    %xq1 = icmp ult i64 %xc, %xl
    br i1 %xq1, label %thenb, label %elseb

  thenb:
    %xr2 = add i64 %x, %a1a1
    %p1 = getelementptr i64, i64* %a11, i64 %xr2
    store i64 %xl, i64* %p1
    %xt1 = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xu1 = insertvalue { i64, i1 } zeroinitializer, i64 %xga1, 0
    %x11 = insertvalue { i64, i1 } %xu1, i1 1, 1
    %x12 = insertvalue { i64*, { i64, i1 } } %xt1, { i64, i1 } %x11, 1
    br label %ctd_ifb

  elseb:
    %xr3 = insertvalue { i64*, { i64, i1 } } zeroinitializer, i64* %a11, 0
    %xs1 = insertvalue { i64, i1 } zeroinitializer, i64 %a1a1, 0
    %x13 = insertvalue { i64, i1 } %xs1, i1 0, 1
    %x14 = insertvalue { i64*, { i64, i1 } } %xr3, { i64, i1 } %x13, 1
    br label %ctd_ifb

  ctd_ifb:
    %x15 = phi { i64*, { i64, i1 } } [ %x14, %elseb ], [ %x12, %thenb ]
    br label %ctd_if

  ctd_if:
    %x16 = phi { i64*, { i64, i1 } } [ %x15, %ctd_ifb ], [ %x10, %ctd_ifa ]
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, { i64, i1 } } %xda, 0
    %xea2 = extractvalue { i64*, { i64, i1 } } %xda, 1
    %a1a2 = extractvalue { i64, i1 } %xea2, 0
    %a2a2 = extractvalue { i64, i1 } %xea2, 1
    %xfa2 = sub i64 %x1, %x
    %xga2 = udiv i64 %xfa2, 2
    %xh1 = icmp slt i64 %a1a2, %xga2
    br i1 %xh1, label %thenc, label %elsec

  thenc:
    %xi1 = mul i64 2, %a1a2
    %xja = add i64 %xi1, 1
    %xk1 = add i64 %x, %xja
    %xl1 = getelementptr i64, i64* %a12, i64 %xk1
    %xm1 = load i64, i64* %xl1
    %xn1 = icmp ult i64 %xc, %xm1
    br i1 %xn1, label %thend, label %elsed

  thend:
    %xo1 = add i64 %x, %a1a2
    %p2 = getelementptr i64, i64* %a12, i64 %xo1
    store i64 %xm1, i64* %p2
    %xq2 = add i64 %x, %xja
    %pa = getelementptr i64, i64* %a12, i64 %xq2
    store i64 %xc, i64* %pa
    br label %ctd_ifd

  elsed:
    %xo2 = add i64 %x, %a1a2
    %p3 = getelementptr i64, i64* %a12, i64 %xo2
    store i64 %xc, i64* %p3
    br label %ctd_ifd

  ctd_ifd:
    %x17 = phi i64* [ %a12, %elsed ], [ %a12, %thend ]
    br label %ctd_ifc

  elsec:
    %xi2 = add i64 %x, %a1a2
    %p4 = getelementptr i64, i64* %a12, i64 %xi2
    store i64 %xc, i64* %p4
    br label %ctd_ifc

  ctd_ifc:
    %x18 = phi i64* [ %a12, %elsec ], [ %x17, %ctd_ifd ]
    ret i64* %x18
}

define i64* @Sorting_Heapsort_heapsort_interp_heapify_btu_impl(i64 %x, i64 %x1, i64* %x2) {

  start:
    %xa = sub i64 %x1, 1
    %xb = insertvalue { i64*, i64 } zeroinitializer, i64* %x2, 0
    %xc = insertvalue { i64*, i64 } %xb, i64 %xa, 1
    br label %while_start

  while_start:
    %xaa = phi { i64*, i64 } [ %x5, %while_body ], [ %xc, %start ]
    %a1 = extractvalue { i64*, i64 } %xaa, 0
    %x3 = extractvalue { i64*, i64 } %xaa, 1
    %x4 = icmp slt i64 %x, %x3
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xaa, 0
    %a2 = extractvalue { i64*, i64 } %xaa, 1
    %xba = sub i64 %a2, 1
    %xca = call i64* @Sorting_Heapsort_heapsort_interp_sift_down_impl (i64 %x, i64 %x1, i64 %xba, i64* %a11)
    %xda = insertvalue { i64*, i64 } zeroinitializer, i64* %xca, 0
    %x5 = insertvalue { i64*, i64 } %xda, i64 %xba, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xaa, 0
    %a21 = extractvalue { i64*, i64 } %xaa, 1
    ret i64* %a12
}
