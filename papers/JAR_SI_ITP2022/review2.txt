Reviewer 2
Main comments:

This is an excellent extension of an already excellent ITP'23
paper. Apart from various sloppy formatting issues with the maths in
this paper, I think this is ready to be accepted. 

The new content in this journal version is the verified parallel
partitioning algorithm, which is well explained. I particularly liked
Figure 3 which made it very clear how most of the partitioning can be
done in parallel.

Minor comments:

There is a formatting error at "The formalization is available
at". Since this is the first sentence of a new paragraph, the text
should be indented.
# done

The math notation in Sec 1.2 is strangely squished together. For
example, in "x≤4" the less-than-or-eq sign nearly touches the x. I
wonder if some space hack has been applied that removes as much space
in math as possible. I find this really hard to read. The authors must
fix the strange space issue.
# we use the listings package for rendering Isabelle text, which is not particularly good at spacing.
# I have now fixed these and various other spacing issues.

The same problem with spacing appears in Sec 2.1 at "r=x".
# fixed

However, suddenly in Sec 2.2 there are parts where there is too much
space. It seems the math formatting isn't using \mathit{..} around
ADDR and ALLOC, and, as a result, one gets ADDR as almost "A D D R"
and ALLOC as "A L L O C".
# This is the spacing generated by mathit for upper-case letters. Afaik, unless some low-level space hacks are used, upper-case words will always be rendered like this, be it in mathit, or listings, or plain text.


Page 6 has more math spacing issues: "r1∪ r2, w1∪ w2, a1∪ a2, f1∪ f2"
-- why is there no space between the first var and union, but there is
a space between the union and the second variable? There seems to be
many such type setting errors, e.g. "xs1 @xs2" on page 15.
# fixed

The C++ code shown at the bottom of page 7 should probably be in alltt
format to clearly indicate that it isn't math.
# done

I thought "indexes" was a typo, but found out that it's an acceptable
spelling of the plural of index. I would have expected "indices".
# I typically use 'indexes'. Now consistently (there was one 'indices' in the document)

"Only then we used our" 
--> 
"Only then did we use switch to our"
or
"Only then did we use our"
# done

"At this point, one may ask why not directly verify the C++
implementation" -- no change in the text is needed here, but I suspect
it's harder to build abstractions from the C++ code. What I'm trying
to say is that the proof effort would be greater, or at least the
person doing the proofs would have to write a lot more. One might also
need to work with LLVM code generated from the C++ code or rely on a
semantics for a subset of C++ (which sounds daunting to me). My point
is that this text comes across as suggesting working upwards in the
proof might be as much effort, but I don't think so. Top down sounds
like less effort in the proofs (but perhaps not in finding a
performant implementation).
# That's an interesting question. The short answer is that we have nice and usable tools for top-down verification, but not so for bottom-up verification of full-fledged C++. Refraining to a small fragment of C++ would annihilate all the advantages of having a nice and clean program for experimentation. The same holds for LLVM: we have tools to create a fragment of LLVM in an top-down approach, but not to import the complete LLVM fragment used by C++ compilers. Also, the semantic annotations like invariants etc. must be translated if you don't want to loose your mind on re-constructing them from LLVM for bottom-up verification.


missing space "it efficient”[32, Sec. 2]"
# fixed
