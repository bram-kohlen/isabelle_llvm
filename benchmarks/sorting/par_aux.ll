; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"


declare void @parallel( void (i8 *) *, void (i8 *) *, i8 *, i8 * )

%resT = type i64*
%funT = type %resT (%argT) *
%argT = type { i64*, { i64, i64 } }

%clT = type {%resT *, %funT, %argT *}

define void @wrapper (i8 * %clpv) {

  %clp = bitcast i8* %clpv to %clT *

  %cl = load %clT, %clT *%clp

  %resp = extractvalue %clT %cl, 0
  %funp = extractvalue %clT %cl, 1
  %argp = extractvalue %clT %cl, 2

  %arg = load %argT, %argT* %argp

  %res = call %resT %funp (%argT %arg)

  store %resT %res, %resT *%resp

  ret void
}

%resT1 = type i64*
%argT1 = type { i64*, { i64, i64 } }

%funT1 = type %resT1 (%argT1) *
%clT1 = type {%resT1 *, %funT1, %argT1 *}

%resT2 = type i64*
%argT2 = type { i64*, { i64, i64 } }

%funT2 = type %resT2 (%argT2) *
%clT2 = type {%resT2 *, %funT2, %argT2 *}

define {%resT1, %resT2} @isabelle_hack_the_par_call(%funT1 %f1, %funT2 %f2, %argT1 %arg1, %argT2 %arg2) {
  ; Build closure1
  %resp1 = alloca %resT1
  %argp1 = alloca %argT1
  store %argT1 %arg1, %argT1* %argp1

  %cl1a = insertvalue %clT1 zeroinitializer, %resT1* %resp1, 0
  %cl1b = insertvalue %clT1 %cl1a, %funT1 %f1, 1
  %cl1 = insertvalue %clT1 %cl1b, %argT1* %argp1, 2

  %cl1p = alloca %clT1
  store %clT1 %cl1, %clT1* %cl1p

  ; Build closure2
  %resp2 = alloca %resT2
  %argp2 = alloca %argT2
  store %argT2 %arg2, %argT2* %argp2

  %cl2a = insertvalue %clT2 zeroinitializer, %resT2* %resp2, 0
  %cl2b = insertvalue %clT2 %cl2a, %funT2 %f2, 1
  %cl2 = insertvalue %clT2 %cl2b, %argT2* %argp2, 2

  %cl2p = alloca %clT2
  store %clT2 %cl2, %clT2* %cl2p


  ; Invoke wrappers (TODO: do it in parallel!)

  %cl1pv = bitcast %clT1* %cl1p to i8*
  %cl2pv = bitcast %clT2* %cl2p to i8*

  call void @parallel (void (i8 *) *@wrapper, void (i8 *) *@wrapper, i8 * %cl1pv, i8 * %cl2pv)

  ; Extract results
  %res1 = load %resT1, %resT1* %resp1
  %res2 = load %resT2, %resT2* %resp2

  ; Assemble result
  %resa = insertvalue {%resT1,%resT2} zeroinitializer, %resT1 %res1, 0
  %res = insertvalue {%resT1,%resT2} %resa, %resT2 %res2, 1

  ret {%resT1,%resT2} %res
}



; define { i64*, i64* } @isabelle_hack_the_par_call(i64* ( { i64*, { i64, i64 } } ) *, i64* ( { i64*, { i64, i64 } } ) *, { i64*, { i64, i64 } }, { i64*, { i64, i64 } })
;
;   start:
;
; xxx, ctd here:
;
;   how to redirect these parallel calls to C++ async, or any other suitable thread library.
;
;   all we can do in C/C++ is declare a function
;
;   void parallel ( void f1 *( void *), void f2 *( void * ), void *arg1, void *arg2  ) {
;
;     f1 (arg1) || f2(arg2)
;
;   }
;
;
;   then, a parallel call must provide these wrapper functions.
;   The argument must contain:
;     location of result
;     actual function to be called
;     actual argument
;
;   thus, we generate in LLVM:
;
;     T1 = { resT1 *, resT1 (argT1) *, argT1* }
;     T2 = { resT2 *, resT2 (argT2) *, argT2* }
;
;     definition void @wrapper1 (T1* tp) {
;       %t = load tp
;       %argp = extractelement t, 2
;       %arg = load %argp
;
;       %fp = extractelement t, 1
;       %resp = extractelement t, 1
;
;       %res = call fp (arg)
;
;       store resp, res
;     }
;
;
;
;     r1p = alloca resT1
;     x1p = alloca argT1
;     store x1p, x1
;
;     p1 = alloca T1
;     store p1, {r1p,@f1,x1p}
;
;     r2p = alloca resT2
;     x2p = alloca argT2
;     store x2p, x2
;
;     p2 = alloca T2
;     store p2, {r2p,@f2,x2p}
;
;     call @parallel (@wrapper1, @wrapper2, p1, p2)
;



