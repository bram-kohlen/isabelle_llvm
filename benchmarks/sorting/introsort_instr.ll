; MANUALLY INSTRUMENTED!
; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"


declare void @incr_partitionings()
declare void @incr_partitions()
declare void @print_partition(i64*, i64, i64)

define i64* @IICF_Array_array_swap(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = getelementptr i64, i64* %x, i64 %x1
    %x4 = load i64, i64* %x3
    %x5 = getelementptr i64, i64* %x, i64 %x2
    %x6 = load i64, i64* %x5
    %p = getelementptr i64, i64* %x, i64 %x1
    store i64 %x6, i64* %p
    %p1 = getelementptr i64, i64* %x, i64 %x2
    store i64 %x4, i64* %p1
    ret i64* %x
}

define i64* @introsort(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = call i64* @Sorting_Introsort_introsort_qs_aux_impl (i64* %x, i64 %x1, i64 %x2)
    %x4 = call i64* @Sorting_Insertion_Sort_insertion_sort_impl (i64* %x3, i64 %x1, i64 %x2)
    ret i64* %x4
}

define i64 @Sorting_Introsort_qsp_next_h_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = sub i64 %x2, 1
    br label %while_start

  while_start:
    %s = phi i64 [ %x6, %while_body ], [ %x3, %start ]
    %xa = getelementptr i64, i64* %x, i64 %s
    %x4 = load i64, i64* %xa
    %x5 = icmp ult i64 %x1, %x4
    br i1 %x5, label %while_body, label %while_end

  while_body:
    %x6 = sub i64 %s, 1
    br label %while_start

  while_end:
    ret i64 %s
}

define i64 @Sorting_Introsort_qsp_next_l_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    br label %while_start

  while_start:
    %s = phi i64 [ %x5, %while_body ], [ %x2, %start ]
    %x3 = getelementptr i64, i64* %x, i64 %s
    %xa = load i64, i64* %x3
    %x4 = icmp ult i64 %xa, %x1
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %x5 = add i64 %s, 1
    br label %while_start

  while_end:
    ret i64 %s
}

define { i64*, i64 } @Sorting_Introsort_qs_partition_impl(i64 %x, i64 %x1, i64 %x2, i64* %x3) {

  start:
    %x4 = call i64 @Sorting_Introsort_qsp_next_l_impl (i64* %x3, i64 %x2, i64 %x)
    %xa = call i64 @Sorting_Introsort_qsp_next_h_impl (i64* %x3, i64 %x2, i64 %x1)
    %xb = insertvalue { i64, i64 } zeroinitializer, i64 %x4, 0
    %tmpa = insertvalue { i64, i64 } %xb, i64 %xa, 1
    %xc = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %x3, 0
    %xd = insertvalue { i64*, { i64, i64 } } %xc, { i64, i64 } %tmpa, 1
    br label %while_start

  while_start:
    %xba = phi { i64*, { i64, i64 } } [ %x8, %while_body ], [ %xd, %start ]
    %a1 = extractvalue { i64*, { i64, i64 } } %xba, 0
    %xca = extractvalue { i64*, { i64, i64 } } %xba, 1
    %a = extractvalue { i64, i64 } %xca, 0
    %x5 = extractvalue { i64, i64 } %xca, 1
    %x6 = icmp slt i64 %a, %x5
    br i1 %x6, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, { i64, i64 } } %xba, 0
    %xca1 = extractvalue { i64*, { i64, i64 } } %xba, 1
    %a1a = extractvalue { i64, i64 } %xca1, 0
    %a2a = extractvalue { i64, i64 } %xca1, 1
    %xda = call i64* @IICF_Array_array_swap (i64* %a11, i64 %a1a, i64 %a2a)
    %xea = add i64 %a1a, 1
    %xf = call i64 @Sorting_Introsort_qsp_next_l_impl (i64* %xda, i64 %x2, i64 %xea)
    %xg = call i64 @Sorting_Introsort_qsp_next_h_impl (i64* %xda, i64 %x2, i64 %a2a)
    %xh = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %xda, 0
    %xi = insertvalue { i64, i64 } zeroinitializer, i64 %xf, 0
    %x7 = insertvalue { i64, i64 } %xi, i64 %xg, 1
    %x8 = insertvalue { i64*, { i64, i64 } } %xh, { i64, i64 } %x7, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, { i64, i64 } } %xba, 0
    %xca2 = extractvalue { i64*, { i64, i64 } } %xba, 1
    %a1a1 = extractvalue { i64, i64 } %xca2, 0
    %a2a1 = extractvalue { i64, i64 } %xca2, 1
    %xda1 = insertvalue { i64*, i64 } zeroinitializer, i64* %a12, 0
    %x9 = insertvalue { i64*, i64 } %xda1, i64 %a1a1, 1
    ret { i64*, i64 } %x9
}

define i64* @Sorting_Insertion_Sort_is_insert_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = getelementptr i64, i64* %x, i64 %x2
    %xa = load i64, i64* %x3
    %xb = insertvalue { i64*, i64 } zeroinitializer, i64* %x, 0
    %xc = insertvalue { i64*, i64 } %xb, i64 %x2, 1
    br label %while_start

  while_start:
    %xba = phi { i64*, i64 } [ %x7, %while_body ], [ %xc, %start ]
    %a1 = extractvalue { i64*, i64 } %xba, 0
    %a2 = extractvalue { i64*, i64 } %xba, 1
    %xca = icmp slt i64 %x1, %a2
    br i1 %xca, label %then, label %else

  then:
    %xda = sub i64 %a2, 1
    %xe = getelementptr i64, i64* %a1, i64 %xda
    %x4 = load i64, i64* %xe
    %x5 = icmp ult i64 %xa, %x4
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x6 = phi i1 [ 0, %else ], [ %x5, %then ]
    br i1 %x6, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xba, 0
    %a21 = extractvalue { i64*, i64 } %xba, 1
    %xca1 = sub i64 %a21, 1
    %xda1 = getelementptr i64, i64* %a11, i64 %xca1
    %xe1 = load i64, i64* %xda1
    %p = getelementptr i64, i64* %a11, i64 %a21
    store i64 %xe1, i64* %p
    %xga = sub i64 %a21, 1
    %xh = insertvalue { i64*, i64 } zeroinitializer, i64* %a11, 0
    %x7 = insertvalue { i64*, i64 } %xh, i64 %xga, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xba, 0
    %a22 = extractvalue { i64*, i64 } %xba, 1
    %p1 = getelementptr i64, i64* %a12, i64 %a22
    store i64 %xa, i64* %p1
    ret i64* %a12
}

define { i64*, i64 } @Sorting_Introsort_partition_pivot_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = sub i64 %x2, %x1
    %xa = udiv i64 %x3, 2
    %xb = add i64 %x1, %xa
    %xc = add i64 %x1, 1
    %xd = sub i64 %x2, 1
    %xe = call i64* @Sorting_Introsort_move_median_to_first_impl (i64 %x1, i64 %xc, i64 %xb, i64 %xd, i64* %x)
    %xf = add i64 %x1, 1
    %xg = getelementptr i64, i64* %xe, i64 %x1
    %xh = load i64, i64* %xg
    %xi = call { i64*, i64 } @Sorting_Introsort_qs_partition_impl (i64 %xf, i64 %x2, i64 %xh, i64* %xe)
    %a = extractvalue { i64*, i64 } %xi, 0
    %b = extractvalue { i64*, i64 } %xi, 1
    %xj = insertvalue { i64*, i64 } zeroinitializer, i64* %a, 0
    %x4 = insertvalue { i64*, i64 } %xj, i64 %b, 1
    ret { i64*, i64 } %x4
}

define i64* @Sorting_Introsort_introsort_qs_aux_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = insertvalue { i64, i64 } zeroinitializer, i64 %x1, 0
    %tmpa = insertvalue { i64, i64 } %x3, i64 %x2, 1
    %xa = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %x, 0
    %x4 = insertvalue { i64*, { i64, i64 } } %xa, { i64, i64 } %tmpa, 1
    %x5 = call i64* @Sorting_Introsort_introsort_qs_aux_impl_f_010477048 ({ i64*, { i64, i64 } } %x4)
    ret i64* %x5
}

define i64* @Sorting_Insertion_Sort_insertion_sort_impl(i64* %x, i64 %x1, i64 %x2) {

  start:
    %x3 = insertvalue { i64*, i64 } zeroinitializer, i64* %x, 0
    %xa = insertvalue { i64*, i64 } %x3, i64 %x1, 1
    br label %while_start

  while_start:
    %xb = phi { i64*, i64 } [ %x5, %while_body ], [ %xa, %start ]
    %a1 = extractvalue { i64*, i64 } %xb, 0
    %a2 = extractvalue { i64*, i64 } %xb, 1
    %x4 = icmp slt i64 %a2, %x2
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64*, i64 } %xb, 0
    %a21 = extractvalue { i64*, i64 } %xb, 1
    %xaa = call i64* @Sorting_Insertion_Sort_is_insert_impl (i64* %a11, i64 %x1, i64 %a21)
    %xba = add i64 %a21, 1
    %xca = insertvalue { i64*, i64 } zeroinitializer, i64* %xaa, 0
    %x5 = insertvalue { i64*, i64 } %xca, i64 %xba, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64*, i64 } %xb, 0
    %a22 = extractvalue { i64*, i64 } %xb, 1
    ret i64* %a12
}

define i64* @Sorting_Introsort_move_median_to_first_impl(i64 %x, i64 %x1, i64 %x2, i64 %x3, i64* %x4) {

  start:
    %x5 = getelementptr i64, i64* %x4, i64 %x1
    %x6 = load i64, i64* %x5
    %x7 = getelementptr i64, i64* %x4, i64 %x2
    %x8 = load i64, i64* %x7
    %x9 = getelementptr i64, i64* %x4, i64 %x3
    %x10 = load i64, i64* %x9
    %x11 = icmp ult i64 %x6, %x8
    br i1 %x11, label %then, label %else

  then:
    %x12 = icmp ult i64 %x8, %x10
    br i1 %x12, label %thena, label %elsea

  thena:
    %x13 = call i64* @IICF_Array_array_swap (i64* %x4, i64 %x, i64 %x2)
    br label %ctd_ifa

  elsea:
    %x14 = icmp ult i64 %x6, %x10
    br i1 %x14, label %thenb, label %elseb

  thenb:
    %x15 = call i64* @IICF_Array_array_swap (i64* %x4, i64 %x, i64 %x3)
    br label %ctd_ifb

  elseb:
    %x16 = call i64* @IICF_Array_array_swap (i64* %x4, i64 %x, i64 %x1)
    br label %ctd_ifb

  ctd_ifb:
    %x17 = phi i64* [ %x16, %elseb ], [ %x15, %thenb ]
    br label %ctd_ifa

  ctd_ifa:
    %x18 = phi i64* [ %x17, %ctd_ifb ], [ %x13, %thena ]
    br label %ctd_if

  else:
    %x19 = icmp ult i64 %x6, %x10
    br i1 %x19, label %thenc, label %elsec

  thenc:
    %x20 = call i64* @IICF_Array_array_swap (i64* %x4, i64 %x, i64 %x1)
    br label %ctd_ifc

  elsec:
    %x21 = icmp ult i64 %x8, %x10
    br i1 %x21, label %thend, label %elsed

  thend:
    %x22 = call i64* @IICF_Array_array_swap (i64* %x4, i64 %x, i64 %x3)
    br label %ctd_ifd

  elsed:
    %x23 = call i64* @IICF_Array_array_swap (i64* %x4, i64 %x, i64 %x2)
    br label %ctd_ifd

  ctd_ifd:
    %x24 = phi i64* [ %x23, %elsed ], [ %x22, %thend ]
    br label %ctd_ifc

  ctd_ifc:
    %x25 = phi i64* [ %x24, %ctd_ifd ], [ %x20, %thenc ]
    br label %ctd_if

  ctd_if:
    %x26 = phi i64* [ %x25, %ctd_ifc ], [ %x18, %ctd_ifa ]
    ret i64* %x26
}

define i64* @Sorting_Introsort_introsort_qs_aux_impl_f_010477048({ i64*, { i64, i64 } } %x) {

  start:
    %a1 = extractvalue { i64*, { i64, i64 } } %x, 0
    %xaa = extractvalue { i64*, { i64, i64 } } %x, 1
    %a1a = extractvalue { i64, i64 } %xaa, 0
    %a2a = extractvalue { i64, i64 } %xaa, 1
    %xba = sub i64 %a2a, %a1a
    %xc = icmp slt i64 16, %xba
    br i1 %xc, label %then, label %else

  then:
    call void @incr_partitionings()
    call void @print_partition(i64* %a1, i64 %a1a, i64 %a2a)
    %xd = call { i64*, i64 } @Sorting_Introsort_partition_pivot_impl (i64* %a1, i64 %a1a, i64 %a2a)
    call void @print_partition(i64* %a1, i64 %a1a, i64 %a2a)

    %a1b = extractvalue { i64*, i64 } %xd, 0
    %a2b = extractvalue { i64*, i64 } %xd, 1
    %xea = add i64 %a1a, 0
    %xf = insertvalue { i64, i64 } zeroinitializer, i64 %xea, 0
    %tmpba = insertvalue { i64, i64 } %xf, i64 %a2b, 1
    %xg = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %a1b, 0
    %xh = insertvalue { i64*, { i64, i64 } } %xg, { i64, i64 } %tmpba, 1
    %xfa = call i64* @Sorting_Introsort_introsort_qs_aux_impl_f_010477048 ({ i64*, { i64, i64 } } %xh)
    %xi = insertvalue { i64, i64 } zeroinitializer, i64 %a2b, 0
    %tmpcb = insertvalue { i64, i64 } %xi, i64 %a2a, 1
    %xj = insertvalue { i64*, { i64, i64 } } zeroinitializer, i64* %xfa, 0
    %x1 = insertvalue { i64*, { i64, i64 } } %xj, { i64, i64 } %tmpcb, 1
    %x2 = call i64* @Sorting_Introsort_introsort_qs_aux_impl_f_010477048 ({ i64*, { i64, i64 } } %x1)
    br label %ctd_if

  else:
    call void @incr_partitions()
    br label %ctd_if

  ctd_if:
    %x3 = phi i64* [ %a1, %else ], [ %x2, %then ]
    ret i64* %x3
}
