; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"



declare void @isabelle_llvm_free(i8*)
declare i8* @isabelle_llvm_calloc(i64, i64)


define void @NArray_narray_free(i64* %p) {

  start:
    %a = ptrtoint i64* %p to i64
    %b = ptrtoint i64* null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i64* %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define { i64, { i64, i64* } } @Array_List_arl_resize(i64 %c, { i64, { i64, i64* } } %al) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %c1 = extractvalue { i64, i64* } %x, 0
    %a = extractvalue { i64, i64* } %x, 1
    %r = sub i64 0, 1
    %max = lshr i64 %r, 1
    %maxa = udiv i64 %max, 2
    %b = icmp ule i64 %c1, %maxa
    br i1 %b, label %then, label %else

  then:
    %ca = mul i64 %c1, 2
    %cok = icmp sle i64 %c, %ca
    br i1 %cok, label %thena, label %elsea

  thena:
    br label %ctd_ifa

  elsea:
    br label %ctd_ifa

  ctd_ifa:
    %x1 = phi i64 [ %ca, %thena ], [ %c, %elsea ]
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %caa = phi i64 [ %x1, %ctd_ifa ], [ %c, %else ]
    %tmpc = icmp eq i64 %caa, 0
    br i1 %tmpc, label %thenb, label %elseb

  thenb:
    br label %ctd_ifb

  elseb:
    %t = getelementptr i64, i64* null, i64 1
    %d = ptrtoint i64* %t to i64
    %x1a = call i8* @isabelle_llvm_calloc (i64 %caa, i64 %d)
    %x1b = bitcast i8* %x1a to i64*
    br label %ctd_ifb

  ctd_ifb:
    %a1 = phi i64* [ null, %thenb ], [ %x1b, %elseb ]
    call void @LLVM_Shallow_RS_arraycpy (i64* %a1, i64* %a, i64 %l)
    call void @NArray_narray_free (i64* %a)
    %xaa = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %l, 0
    %xe = insertvalue { i64, i64* } zeroinitializer, i64 %caa, 0
    %x1c = insertvalue { i64, i64* } %xe, i64* %a1, 1
    %x2 = insertvalue { i64, { i64, i64* } } %xaa, { i64, i64* } %x1c, 1
    ret { i64, { i64, i64* } } %x2
}

define i64 @cr_big_al(i64 %n) {

  start:
    %tmpd = icmp eq i64 8, 0
    br i1 %tmpd, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i64, i64* null, i64 1
    %a = ptrtoint i64* %t to i64
    %x = call i8* @isabelle_llvm_calloc (i64 8, i64 %a)
    %xa = bitcast i8* %x to i64*
    br label %ctd_if

  ctd_if:
    %aa = phi i64* [ null, %then ], [ %xa, %else ]
    %xb = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 0, 0
    %xc = insertvalue { i64, i64* } zeroinitializer, i64 8, 0
    %xd = insertvalue { i64, i64* } %xc, i64* %aa, 1
    %aaa = insertvalue { i64, { i64, i64* } } %xb, { i64, i64* } %xd, 1
    %xe = insertvalue { i64, { i64, { i64, i64* } } } zeroinitializer, i64 %n, 0
    %xf = insertvalue { i64, { i64, { i64, i64* } } } %xe, { i64, { i64, i64* } } %aaa, 1
    %xaa = call { i64, { i64, { i64, i64* } } } @LLVM_Examples_cr_big_al_0 ({ i64, { i64, { i64, i64* } } } %xf)
    %uu = extractvalue { i64, { i64, { i64, i64* } } } %xaa, 0
    %ab = extractvalue { i64, { i64, { i64, i64* } } } %xaa, 1
    %xg = insertvalue { i64, i64 } zeroinitializer, i64 %n, 0
    %xh = insertvalue { i64, i64 } %xg, i64 0, 1
    %xba = call { i64, i64 } @LLVM_Examples_cr_big_al_1 ({ i64, { i64, i64* } } %ab, { i64, i64 } %xh)
    %uua = extractvalue { i64, i64 } %xba, 0
    %xi = extractvalue { i64, i64 } %xba, 1
    ret i64 %xi
}

define void @LLVM_Shallow_RS_arraycpy(i64* %dst, i64* %src, i64 %n) {

  start:
    %uu = call i64 @LLVM_Shallow_RS_arraycpy_0 (i64* %dst, i64* %src, i64 %n, i64 0)
    ret void
}

define { i64, { i64, { i64, i64* } } } @LLVM_Examples_cr_big_al_0({ i64, { i64, { i64, i64* } } } %s) {

  start:
    %n = extractvalue { i64, { i64, { i64, i64* } } } %s, 0
    %a = extractvalue { i64, { i64, { i64, i64* } } } %s, 1
    %ctd = icmp ult i64 0, %n
    br i1 %ctd, label %then, label %else

  then:
    %na = extractvalue { i64, { i64, { i64, i64* } } } %s, 0
    %aa = extractvalue { i64, { i64, { i64, i64* } } } %s, 1
    %l = extractvalue { i64, { i64, i64* } } %aa, 0
    %x = extractvalue { i64, { i64, i64* } } %aa, 1
    %c = extractvalue { i64, i64* } %x, 0
    %ab = extractvalue { i64, i64* } %x, 1
    %lb = add i64 %l, 1
    %lc = extractvalue { i64, { i64, i64* } } %aa, 0
    %xaa = extractvalue { i64, { i64, i64* } } %aa, 1
    %ca = extractvalue { i64, i64* } %xaa, 0
    %ac = extractvalue { i64, i64* } %xaa, 1
    %cok = icmp sle i64 %lb, %ca
    br i1 %cok, label %thena, label %elsea

  thena:
    %xb = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %lc, 0
    %xc = insertvalue { i64, i64* } zeroinitializer, i64 %ca, 0
    %x1 = insertvalue { i64, i64* } %xc, i64* %ac, 1
    %x2 = insertvalue { i64, { i64, i64* } } %xb, { i64, i64* } %x1, 1
    br label %ctd_ifa

  elsea:
    %xba = insertvalue { i64, i64* } zeroinitializer, i64 %ca, 0
    %tmpa = insertvalue { i64, i64* } %xba, i64* %ac, 1
    %xca = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %lc, 0
    %x1a = insertvalue { i64, { i64, i64* } } %xca, { i64, i64* } %tmpa, 1
    %x2a = call { i64, { i64, i64* } } @Array_List_arl_resize (i64 %lb, { i64, { i64, i64* } } %x1a)
    br label %ctd_ifa

  ctd_ifa:
    %al = phi { i64, { i64, i64* } } [ %x2, %thena ], [ %x2a, %elsea ]
    %ld = extractvalue { i64, { i64, i64* } } %al, 0
    %xbb = extractvalue { i64, { i64, i64* } } %al, 1
    %cb = extractvalue { i64, i64* } %xbb, 0
    %ad = extractvalue { i64, i64* } %xbb, 1
    %p = getelementptr i64, i64* %ad, i64 %ld
    store i64 %na, i64* %p
    %le = add i64 %ld, 1
    %xcaa = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %le, 0
    %xd = insertvalue { i64, i64* } zeroinitializer, i64 %cb, 0
    %xe = insertvalue { i64, i64* } %xd, i64* %ad, 1
    %ae = insertvalue { i64, { i64, i64* } } %xcaa, { i64, i64* } %xe, 1
    %nb = sub i64 %na, 1
    %xda = insertvalue { i64, { i64, { i64, i64* } } } zeroinitializer, i64 %nb, 0
    %x1b = insertvalue { i64, { i64, { i64, i64* } } } %xda, { i64, { i64, i64* } } %ae, 1
    %x2b = call { i64, { i64, { i64, i64* } } } @LLVM_Examples_cr_big_al_0 ({ i64, { i64, { i64, i64* } } } %x1b)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %xa = phi { i64, { i64, { i64, i64* } } } [ %x2b, %ctd_ifa ], [ %s, %else ]
    ret { i64, { i64, { i64, i64* } } } %xa
}

define { i64, i64 } @LLVM_Examples_cr_big_al_1({ i64, { i64, i64* } } %a, { i64, i64 } %s) {

  start:
    %n = extractvalue { i64, i64 } %s, 0
    %s1 = extractvalue { i64, i64 } %s, 1
    %ctd = icmp ult i64 0, %n
    br i1 %ctd, label %then, label %else

  then:
    %na = extractvalue { i64, i64 } %s, 0
    %sa = extractvalue { i64, i64 } %s, 1
    %nb = sub i64 %na, 1
    %l = extractvalue { i64, { i64, i64* } } %a, 0
    %x = extractvalue { i64, { i64, i64* } } %a, 1
    %c = extractvalue { i64, i64* } %x, 0
    %a1 = extractvalue { i64, i64* } %x, 1
    %xa = getelementptr i64, i64* %a1, i64 %nb
    %xb = load i64, i64* %xa
    %sb = add i64 %xb, %sa
    %xc = insertvalue { i64, i64 } zeroinitializer, i64 %nb, 0
    %x1 = insertvalue { i64, i64 } %xc, i64 %sb, 1
    %x2 = call { i64, i64 } @LLVM_Examples_cr_big_al_1 ({ i64, { i64, i64* } } %a, { i64, i64 } %x1)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %xd = phi { i64, i64 } [ %x2, %then ], [ %s, %else ]
    ret { i64, i64 } %xd
}

define i64 @LLVM_Shallow_RS_arraycpy_0(i64* %dst, i64* %src, i64 %n, i64 %s) {

  start:
    %ctd = icmp ult i64 %s, %n
    br i1 %ctd, label %then, label %else

  then:
    %x = getelementptr i64, i64* %src, i64 %s
    %xa = load i64, i64* %x
    %p = getelementptr i64, i64* %dst, i64 %s
    store i64 %xa, i64* %p
    %x1 = add i64 %s, 1
    %x2 = call i64 @LLVM_Shallow_RS_arraycpy_0 (i64* %dst, i64* %src, i64 %n, i64 %x1)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %xb = phi i64 [ %x2, %then ], [ %s, %else ]
    ret i64 %xb
}
