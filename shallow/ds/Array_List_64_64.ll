; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"



declare void @isabelle_llvm_free(i8*)
declare i8* @isabelle_llvm_calloc(i64, i64)


define i64 @arl_len({ i64, { i64, i64* } } %al) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %c = extractvalue { i64, i64* } %x, 0
    %a = extractvalue { i64, i64* } %x, 1
    ret i64 %l
}

define i64 @arl_nth({ i64, { i64, i64* } } %al, i64 %i) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %c = extractvalue { i64, i64* } %x, 0
    %a = extractvalue { i64, i64* } %x, 1
    %x1 = getelementptr i64, i64* %a, i64 %i
    %x2 = load i64, i64* %x1
    ret i64 %x2
}

define { i64, { i64, i64* } } @arl_upd({ i64, { i64, i64* } } %al, i64 %i, i64 %x) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x1 = extractvalue { i64, { i64, i64* } } %al, 1
    %c = extractvalue { i64, i64* } %x1, 0
    %a = extractvalue { i64, i64* } %x1, 1
    %p = getelementptr i64, i64* %a, i64 %i
    store i64 %x, i64* %p
    %xa = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %l, 0
    %xb = insertvalue { i64, i64* } zeroinitializer, i64 %c, 0
    %x2 = insertvalue { i64, i64* } %xb, i64* %a, 1
    %x3 = insertvalue { i64, { i64, i64* } } %xa, { i64, i64* } %x2, 1
    ret { i64, { i64, i64* } } %x3
}

define void @NArray_narray_free(i64* %p) {

  start:
    %a = ptrtoint i64* %p to i64
    %b = ptrtoint i64* null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i64* %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define void @arl_free({ i64, { i64, i64* } } %al) {

  start:
    %uu = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %uua = extractvalue { i64, i64* } %x, 0
    %x1 = extractvalue { i64, i64* } %x, 1
    call void @NArray_narray_free (i64* %x1)
    ret void
}

define { i64, { i64, i64* } } @arl_take({ i64, { i64, i64* } } %al, i64 %l) {

  start:
    %l1 = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %c = extractvalue { i64, i64* } %x, 0
    %a = extractvalue { i64, i64* } %x, 1
    %xa = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %l, 0
    %xb = insertvalue { i64, i64* } zeroinitializer, i64 %c, 0
    %x1 = insertvalue { i64, i64* } %xb, i64* %a, 1
    %x2 = insertvalue { i64, { i64, i64* } } %xa, { i64, i64* } %x1, 1
    ret { i64, { i64, i64* } } %x2
}

define { i64, { i64, i64* } } @Array_List_arl_resize(i64 %c, { i64, { i64, i64* } } %al) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %c1 = extractvalue { i64, i64* } %x, 0
    %a = extractvalue { i64, i64* } %x, 1
    %r = sub i64 0, 1
    %max = lshr i64 %r, 1
    %maxa = udiv i64 %max, 2
    %b = icmp ule i64 %c1, %maxa
    br i1 %b, label %then, label %else

  then:
    %ca = mul i64 %c1, 2
    %cok = icmp sle i64 %c, %ca
    br i1 %cok, label %thena, label %elsea

  thena:
    br label %ctd_ifa

  elsea:
    br label %ctd_ifa

  ctd_ifa:
    %x1 = phi i64 [ %ca, %thena ], [ %c, %elsea ]
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %caa = phi i64 [ %x1, %ctd_ifa ], [ %c, %else ]
    %tmpc = icmp eq i64 %caa, 0
    br i1 %tmpc, label %thenb, label %elseb

  thenb:
    br label %ctd_ifb

  elseb:
    %t = getelementptr i64, i64* null, i64 1
    %d = ptrtoint i64* %t to i64
    %x1a = call i8* @isabelle_llvm_calloc (i64 %caa, i64 %d)
    %x1b = bitcast i8* %x1a to i64*
    br label %ctd_ifb

  ctd_ifb:
    %a1 = phi i64* [ null, %thenb ], [ %x1b, %elseb ]
    call void @LLVM_Shallow_RS_arraycpy (i64* %a1, i64* %a, i64 %l)
    call void @NArray_narray_free (i64* %a)
    %xaa = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %l, 0
    %xe = insertvalue { i64, i64* } zeroinitializer, i64 %caa, 0
    %x1c = insertvalue { i64, i64* } %xe, i64* %a1, 1
    %x2 = insertvalue { i64, { i64, i64* } } %xaa, { i64, i64* } %x1c, 1
    ret { i64, { i64, i64* } } %x2
}

define { i64, { i64, i64* } } @arl_new() {

  start:
    %tmpd = icmp eq i64 8, 0
    br i1 %tmpd, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i64, i64* null, i64 1
    %a = ptrtoint i64* %t to i64
    %x = call i8* @isabelle_llvm_calloc (i64 8, i64 %a)
    %xa = bitcast i8* %x to i64*
    br label %ctd_if

  ctd_if:
    %aa = phi i64* [ null, %then ], [ %xa, %else ]
    %xb = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 0, 0
    %xc = insertvalue { i64, i64* } zeroinitializer, i64 8, 0
    %xd = insertvalue { i64, i64* } %xc, i64* %aa, 1
    %x1 = insertvalue { i64, { i64, i64* } } %xb, { i64, i64* } %xd, 1
    ret { i64, { i64, i64* } } %x1
}

define { i64, { i64, { i64, i64* } } } @arl_pop_back({ i64, { i64, i64* } } %al) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x = extractvalue { i64, { i64, i64* } } %al, 1
    %c = extractvalue { i64, i64* } %x, 0
    %a = extractvalue { i64, i64* } %x, 1
    %la = sub i64 %l, 1
    %xaa = getelementptr i64, i64* %a, i64 %la
    %r = load i64, i64* %xaa
    %xb = insertvalue { i64, { i64, { i64, i64* } } } zeroinitializer, i64 %r, 0
    %xc = insertvalue { i64, i64* } zeroinitializer, i64 %c, 0
    %tmpaa = insertvalue { i64, i64* } %xc, i64* %a, 1
    %xd = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %la, 0
    %x1 = insertvalue { i64, { i64, i64* } } %xd, { i64, i64* } %tmpaa, 1
    %x2 = insertvalue { i64, { i64, { i64, i64* } } } %xb, { i64, { i64, i64* } } %x1, 1
    ret { i64, { i64, { i64, i64* } } } %x2
}

define { i64, { i64, i64* } } @arl_push_back({ i64, { i64, i64* } } %al, i64 %x) {

  start:
    %l = extractvalue { i64, { i64, i64* } } %al, 0
    %x1 = extractvalue { i64, { i64, i64* } } %al, 1
    %c = extractvalue { i64, i64* } %x1, 0
    %a = extractvalue { i64, i64* } %x1, 1
    %lb = add i64 %l, 1
    %lc = extractvalue { i64, { i64, i64* } } %al, 0
    %xaa = extractvalue { i64, { i64, i64* } } %al, 1
    %ca = extractvalue { i64, i64* } %xaa, 0
    %aa = extractvalue { i64, i64* } %xaa, 1
    %cok = icmp sle i64 %lb, %ca
    br i1 %cok, label %then, label %else

  then:
    %xb = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %lc, 0
    %xc = insertvalue { i64, i64* } zeroinitializer, i64 %ca, 0
    %x2 = insertvalue { i64, i64* } %xc, i64* %aa, 1
    %x3 = insertvalue { i64, { i64, i64* } } %xb, { i64, i64* } %x2, 1
    br label %ctd_if

  else:
    %xba = insertvalue { i64, i64* } zeroinitializer, i64 %ca, 0
    %tmpa = insertvalue { i64, i64* } %xba, i64* %aa, 1
    %xca = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %lc, 0
    %x2a = insertvalue { i64, { i64, i64* } } %xca, { i64, i64* } %tmpa, 1
    %x3a = call { i64, { i64, i64* } } @Array_List_arl_resize (i64 %lb, { i64, { i64, i64* } } %x2a)
    br label %ctd_if

  ctd_if:
    %al1 = phi { i64, { i64, i64* } } [ %x3, %then ], [ %x3a, %else ]
    %ld = extractvalue { i64, { i64, i64* } } %al1, 0
    %xbb = extractvalue { i64, { i64, i64* } } %al1, 1
    %cb = extractvalue { i64, i64* } %xbb, 0
    %ab = extractvalue { i64, i64* } %xbb, 1
    %p = getelementptr i64, i64* %ab, i64 %ld
    store i64 %x, i64* %p
    %le = add i64 %ld, 1
    %xcaa = insertvalue { i64, { i64, i64* } } zeroinitializer, i64 %le, 0
    %xd = insertvalue { i64, i64* } zeroinitializer, i64 %cb, 0
    %x2b = insertvalue { i64, i64* } %xd, i64* %ab, 1
    %x3b = insertvalue { i64, { i64, i64* } } %xcaa, { i64, i64* } %x2b, 1
    ret { i64, { i64, i64* } } %x3b
}

define void @LLVM_Shallow_RS_arraycpy(i64* %dst, i64* %src, i64 %n) {

  start:
    %uu = call i64 @LLVM_Shallow_RS_arraycpy_0 (i64* %dst, i64* %src, i64 %n, i64 0)
    ret void
}

define i64 @LLVM_Shallow_RS_arraycpy_0(i64* %dst, i64* %src, i64 %n, i64 %s) {

  start:
    %ctd = icmp ult i64 %s, %n
    br i1 %ctd, label %then, label %else

  then:
    %x = getelementptr i64, i64* %src, i64 %s
    %xa = load i64, i64* %x
    %p = getelementptr i64, i64* %dst, i64 %s
    store i64 %xa, i64* %p
    %x1 = add i64 %s, 1
    %x2 = call i64 @LLVM_Shallow_RS_arraycpy_0 (i64* %dst, i64* %src, i64 %n, i64 %x1)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %xb = phi i64 [ %x2, %then ], [ %s, %else ]
    ret i64 %xb
}
