; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"



declare void @isabelle_llvm_free(i8*)
declare i8* @isabelle_llvm_calloc(i64, i64)


define i64 @kmp({ i64, i8* } %x, { i64, i8* } %x1) {

  start:
    %a1 = extractvalue { i64, i8* } %x, 0
    %a2 = extractvalue { i64, i8* } %x, 1
    %xa = icmp eq i64 %a1, 0
    br i1 %xa, label %then, label %else

  then:
    br label %ctd_if

  else:
    %xaa = call { i64, i64* } @kmp_compute_table ({ i64, i8* } %x)
    %xb = insertvalue { i64, i64 } zeroinitializer, i64 0, 0
    %tmpaa = insertvalue { i64, i64 } %xb, i64 -1, 1
    %xc = insertvalue { i64, { i64, i64 } } zeroinitializer, i64 0, 0
    %xd = insertvalue { i64, { i64, i64 } } %xc, { i64, i64 } %tmpaa, 1
    %xba = call { i64, { i64, i64 } } @KMP_kmp_impl_1 ({ i64, i8* } %x1, { i64, i8* } %x, { i64, i64* } %xaa, { i64, { i64, i64 } } %xd)
    %a1a = extractvalue { i64, i64* } %xaa, 0
    %xca = extractvalue { i64, i64* } %xaa, 1
    call void @NArray_narray_free (i64* %xca)
    %a1b = extractvalue { i64, { i64, i64 } } %xba, 0
    %b = extractvalue { i64, { i64, i64 } } %xba, 1
    %a1aa = extractvalue { i64, i64 } %b, 0
    %x2 = extractvalue { i64, i64 } %b, 1
    br label %ctd_if

  ctd_if:
    %x2a = phi i64 [ 0, %then ], [ %x2, %else ]
    ret i64 %x2a
}

define { i64, i64 } @KMP_kmp_impl_0({ i64, i8* } %bi, { i64, i8* } %ai, i64 %a1, { i64, i64 } %s) {

  start:
    %a1b = extractvalue { i64, i64 } %s, 0
    %a2b = extractvalue { i64, i64 } %s, 1
    %x = icmp eq i64 -1, %a2b
    br i1 %x, label %then, label %else

  then:
    %xa = add i64 %a1, %a1b
    %a11 = extractvalue { i64, i8* } %bi, 0
    %a2 = extractvalue { i64, i8* } %bi, 1
    %xb = getelementptr i8, i8* %a2, i64 %xa
    %xc = load i8, i8* %xb
    %a1a = extractvalue { i64, i8* } %ai, 0
    %a2a = extractvalue { i64, i8* } %ai, 1
    %xd = getelementptr i8, i8* %a2a, i64 %a1b
    %x1 = load i8, i8* %xd
    %x2 = icmp eq i8 %xc, %x1
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %ctd = phi i1 [ %x2, %then ], [ 0, %else ]
    br i1 %ctd, label %thena, label %elsea

  thena:
    %a1ba = extractvalue { i64, i64 } %s, 0
    %a2ba = extractvalue { i64, i64 } %s, 1
    %xaa = add i64 %a1ba, 1
    %a11a = extractvalue { i64, i8* } %ai, 0
    %a2c = extractvalue { i64, i8* } %ai, 1
    %xca = icmp eq i64 %xaa, %a11a
    br i1 %xca, label %thenb, label %elseb

  thenb:
    %xda = insertvalue { i64, i64 } zeroinitializer, i64 %xaa, 0
    %x1a = insertvalue { i64, i64 } %xda, i64 %a1, 1
    br label %ctd_ifb

  elseb:
    %xdb = insertvalue { i64, i64 } zeroinitializer, i64 %xaa, 0
    %x1b = insertvalue { i64, i64 } %xdb, i64 -1, 1
    br label %ctd_ifb

  ctd_ifb:
    %r = phi { i64, i64 } [ %x1a, %thenb ], [ %x1b, %elseb ]
    %c_1 = extractvalue { i64, i64 } %s, 0
    %b = extractvalue { i64, i64 } %s, 1
    %d = icmp eq i64 -1, %b
    br i1 %d, label %thenc, label %elsec

  thenc:
    br label %ctd_ifc

  elsec:
    br label %ctd_ifc

  ctd_ifc:
    %x1c = call { i64, i64 } @KMP_kmp_impl_0 ({ i64, i8* } %bi, { i64, i8* } %ai, i64 %a1, { i64, i64 } %r)
    br label %ctd_ifa

  elsea:
    br label %ctd_ifa

  ctd_ifa:
    %x1d = phi { i64, i64 } [ %x1c, %ctd_ifc ], [ %s, %elsea ]
    ret { i64, i64 } %x1d
}

define { i64, { i64, i64 } } @KMP_kmp_impl_1({ i64, i8* } %bi, { i64, i8* } %ai, { i64, i64* } %x, { i64, { i64, i64 } } %s) {

  start:
    %a1 = extractvalue { i64, { i64, i64 } } %s, 0
    %x1 = extractvalue { i64, { i64, i64 } } %s, 1
    %a1a = extractvalue { i64, i64 } %x1, 0
    %a2a = extractvalue { i64, i64 } %x1, 1
    %a1b = extractvalue { i64, i8* } %ai, 0
    %a2 = extractvalue { i64, i8* } %ai, 1
    %xb = add i64 %a1, %a1b
    %a1c = extractvalue { i64, i8* } %bi, 0
    %a2b = extractvalue { i64, i8* } %bi, 1
    %xd = icmp ule i64 %xb, %a1c
    %xe = icmp eq i64 -1, %a2a
    %ctd = and i1 %xd, %xe
    br i1 %ctd, label %then, label %else

  then:
    %a1d = extractvalue { i64, { i64, i64 } } %s, 0
    %xf = extractvalue { i64, { i64, i64 } } %s, 1
    %a1aa = extractvalue { i64, i64 } %xf, 0
    %a2aa = extractvalue { i64, i64 } %xf, 1
    %xg = insertvalue { i64, i64 } zeroinitializer, i64 %a1aa, 0
    %xh = insertvalue { i64, i64 } %xg, i64 %a2aa, 1
    %xga = call { i64, i64 } @KMP_kmp_impl_0 ({ i64, i8* } %bi, { i64, i8* } %ai, i64 %a1d, { i64, i64 } %xh)
    %a1ba = extractvalue { i64, i64 } %xga, 0
    %a2ba = extractvalue { i64, i64 } %xga, 1
    %xha = icmp eq i64 -1, %a2ba
    br i1 %xha, label %thena, label %elsea

  thena:
    %a1e = extractvalue { i64, i64* } %x, 0
    %a2c = extractvalue { i64, i64* } %x, 1
    %xi = getelementptr i64, i64* %a2c, i64 %a1ba
    %xj = load i64, i64* %xi
    %xk = sub i64 %a1ba, %xj
    %xla = add i64 %xk, 1
    %xm = add i64 %a1d, %xla
    %a1f = extractvalue { i64, i64* } %x, 0
    %a2d = extractvalue { i64, i64* } %x, 1
    %xn = getelementptr i64, i64* %a2d, i64 %a1ba
    %xo = load i64, i64* %xn
    %xpa = icmp ule i64 %xo, 1
    br i1 %xpa, label %thenb, label %elseb

  thenb:
    br label %ctd_ifb

  elseb:
    %x2 = sub i64 %xo, 1
    br label %ctd_ifb

  ctd_ifb:
    %xq = phi i64 [ 0, %thenb ], [ %x2, %elseb ]
    %xr = insertvalue { i64, { i64, i64 } } zeroinitializer, i64 %xm, 0
    %xs = insertvalue { i64, i64 } zeroinitializer, i64 %xq, 0
    %x2a = insertvalue { i64, i64 } %xs, i64 -1, 1
    %x3 = insertvalue { i64, { i64, i64 } } %xr, { i64, i64 } %x2a, 1
    br label %ctd_ifa

  elsea:
    %xia = insertvalue { i64, { i64, i64 } } zeroinitializer, i64 %a1d, 0
    %xja = insertvalue { i64, i64 } zeroinitializer, i64 %a1ba, 0
    %x2b = insertvalue { i64, i64 } %xja, i64 %a1d, 1
    %x3a = insertvalue { i64, { i64, i64 } } %xia, { i64, i64 } %x2b, 1
    br label %ctd_ifa

  ctd_ifa:
    %r = phi { i64, { i64, i64 } } [ %x3, %ctd_ifb ], [ %x3a, %elsea ]
    %c_1 = extractvalue { i64, i64 } %xga, 0
    %b = extractvalue { i64, i64 } %xga, 1
    %d = icmp eq i64 -1, %b
    br i1 %d, label %thenc, label %elsec

  thenc:
    br label %ctd_ifc

  elsec:
    br label %ctd_ifc

  ctd_ifc:
    %x2c = call { i64, { i64, i64 } } @KMP_kmp_impl_1 ({ i64, i8* } %bi, { i64, i8* } %ai, { i64, i64* } %x, { i64, { i64, i64 } } %r)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x2d = phi { i64, { i64, i64 } } [ %x2c, %ctd_ifc ], [ %s, %else ]
    ret { i64, { i64, i64 } } %x2d
}

define void @NArray_narray_free(i64* %p) {

  start:
    %a = ptrtoint i64* %p to i64
    %b = ptrtoint i64* null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i64* %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define { i64, i64* } @kmp_compute_table({ i64, i8* } %x) {

  start:
    %a1 = extractvalue { i64, i8* } %x, 0
    %a2 = extractvalue { i64, i8* } %x, 1
    %tmp = icmp eq i64 %a1, 0
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i64, i64* null, i64 1
    %a = ptrtoint i64* %t to i64
    %x1 = call i8* @isabelle_llvm_calloc (i64 %a1, i64 %a)
    %x1a = bitcast i8* %x1 to i64*
    br label %ctd_if

  ctd_if:
    %xaa = phi i64* [ null, %then ], [ %x1a, %else ]
    %xb = insertvalue { i64, i64* } zeroinitializer, i64 %a1, 0
    %xc = insertvalue { i64, i64* } %xb, i64* %xaa, 1
    %xd = insertvalue { i64, i64 } zeroinitializer, i64 0, 0
    %tmpc = insertvalue { i64, i64 } %xd, i64 1, 1
    %xe = insertvalue { { i64, i64* }, { i64, i64 } } zeroinitializer, { i64, i64* } %xc, 0
    %xf = insertvalue { { i64, i64* }, { i64, i64 } } %xe, { i64, i64 } %tmpc, 1
    %xda = call { { i64, i64* }, { i64, i64 } } @KMP_compute_butlast_ff_s_impl_1 ({ i64, i8* } %x, { { i64, i64* }, { i64, i64 } } %xf)
    %a1a = extractvalue { { i64, i64* }, { i64, i64 } } %xda, 0
    %xea = extractvalue { { i64, i64* }, { i64, i64 } } %xda, 1
    %a1aa = extractvalue { i64, i64 } %xea, 0
    %a2a = extractvalue { i64, i64 } %xea, 1
    ret { i64, i64* } %a1a
}

define i64 @KMP_compute_butlast_ff_s_impl_0(i64 %a2a, { i64, i8* } %xi, { i64, i64* } %a1, i64 %s) {

  start:
    %x = icmp ult i64 0, %s
    br i1 %x, label %then, label %else

  then:
    %xaa = sub i64 %s, 1
    %a11 = extractvalue { i64, i8* } %xi, 0
    %a2 = extractvalue { i64, i8* } %xi, 1
    %xb = getelementptr i8, i8* %a2, i64 %xaa
    %xc = load i8, i8* %xb
    %xda = sub i64 %a2a, 1
    %a1a = extractvalue { i64, i8* } %xi, 0
    %a2a1 = extractvalue { i64, i8* } %xi, 1
    %xe = getelementptr i8, i8* %a2a1, i64 %xda
    %x1 = load i8, i8* %xe
    %x2 = icmp ne i8 %xc, %x1
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %ctd = phi i1 [ %x2, %then ], [ 0, %else ]
    br i1 %ctd, label %thena, label %elsea

  thena:
    %bi = sub i64 %s, 1
    %a11a = extractvalue { i64, i64* } %a1, 0
    %a2b = extractvalue { i64, i64* } %a1, 1
    %xaaa = getelementptr i64, i64* %a2b, i64 %bi
    %x1a = load i64, i64* %xaaa
    %x2a = call i64 @KMP_compute_butlast_ff_s_impl_0 (i64 %a2a, { i64, i8* } %xi, { i64, i64* } %a1, i64 %x1a)
    br label %ctd_ifa

  elsea:
    br label %ctd_ifa

  ctd_ifa:
    %x1b = phi i64 [ %x2a, %thena ], [ %s, %elsea ]
    ret i64 %x1b
}

define { { i64, i64* }, { i64, i64 } } @KMP_compute_butlast_ff_s_impl_1({ i64, i8* } %xi, { { i64, i64* }, { i64, i64 } } %s) {

  start:
    %a1 = extractvalue { { i64, i64* }, { i64, i64 } } %s, 0
    %x = extractvalue { { i64, i64* }, { i64, i64 } } %s, 1
    %a1a = extractvalue { i64, i64 } %x, 0
    %a2a = extractvalue { i64, i64 } %x, 1
    %a1b = extractvalue { i64, i64* } %a1, 0
    %a2 = extractvalue { i64, i64* } %a1, 1
    %ctd = icmp ult i64 %a2a, %a1b
    br i1 %ctd, label %then, label %else

  then:
    %a1c = extractvalue { { i64, i64* }, { i64, i64 } } %s, 0
    %xb = extractvalue { { i64, i64* }, { i64, i64 } } %s, 1
    %a1aa = extractvalue { i64, i64 } %xb, 0
    %a2aa = extractvalue { i64, i64 } %xb, 1
    %xc = call i64 @KMP_compute_butlast_ff_s_impl_0 (i64 %a2aa, { i64, i8* } %xi, { i64, i64* } %a1c, i64 %a1aa)
    %xda = add i64 %xc, 1
    %a1d = extractvalue { i64, i64* } %a1c, 0
    %a2b = extractvalue { i64, i64* } %a1c, 1
    %p = getelementptr i64, i64* %a2b, i64 %a2aa
    store i64 %xda, i64* %p
    %xf = insertvalue { i64, i64* } zeroinitializer, i64 %a1d, 0
    %xg = insertvalue { i64, i64* } %xf, i64* %a2b, 1
    %xha = add i64 %a2aa, 1
    %xi1 = insertvalue { { i64, i64* }, { i64, i64 } } zeroinitializer, { i64, i64* } %xg, 0
    %xj = insertvalue { i64, i64 } zeroinitializer, i64 %xda, 0
    %xk = insertvalue { i64, i64 } %xj, i64 %xha, 1
    %x1 = insertvalue { { i64, i64* }, { i64, i64 } } %xi1, { i64, i64 } %xk, 1
    %x2 = call { { i64, i64* }, { i64, i64 } } @KMP_compute_butlast_ff_s_impl_1 ({ i64, i8* } %xi, { { i64, i64* }, { i64, i64 } } %x1)
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x1a = phi { { i64, i64* }, { i64, i64 } } [ %x2, %then ], [ %s, %else ]
    ret { { i64, i64* }, { i64, i64 } } %x1a
}
